# Storage

## 持久化（Persistence）

MySQL 持久化文件的主要包含如下内容：

- **数据文件（InnoDB）**
  - 表空间文件（Tablespace Files）：
    - 系统表空间：默认文件名为 `ibdata1`，存储共享数据（如 InnoDB 数据字典、双写缓冲区、Undo 日志等）
    - 独立表空间：每个 InnoDB 表对应一个 `.ibd` 文件（如 `user.ibd`），存储该表的数据和索引
  - 临时表空间：`ibtmp1` 文件，存储临时表和排序操作的数据

- **日志文件**
  - Undo Log：存储事务的撤销信息，用于回滚和 MVCC（多版本并发控制），MySQL 8.0+ 默认将 Undo 日志从系统表空间分离到独立的 `undo_001`、`undo_002` 等文件中
  - Redo Log：文件名为 `ib_logfile0` 和 `ib_logfile1`，记录 InnoDB 引擎的事务操作，用于崩溃恢复
  - Binary Log：文件名为 `binlog.000001`、`binlog.000002` 等，记录所有修改数据的 SQL 语句，用于主从复制和基于时间点的恢复

- **辅助文件**
  - 错误日志（Error Log）：默认文件名为 `hostname.err`，记录 MySQL 运行时的错误和警告信息
  - 慢查询日志（Slow Query Log）：记录执行时间超过 `long_query_time` 阈值的 SQL 语句，用于性能分析
  - 通用日志（General Log）：记录所有客户端连接和 SQL 操作，用于审计和调试
  - 中继日志（Relay Log）：在主从复制中，从库通过 `relay-log.xxxxxx` 文件接收并暂存主库的二进制日志事件
  - 备份文件：通过 `mysqldump` 或物理备份工具（如 Percona XtraBackup）生成的 `.sql` 或 `.xbstream` 文件

### 段、区、页、行

InnoDB 存储引擎采用层级化的物理存储结构，具体如下：

- **行**（Row）
  - 最小数据单元：单条记录（如一行用户数据）
  - 包括用户列的数据信息和其他的额外信息

- **页**（Page）
  - 最小管理单元：默认大小 16KB，是 InnoDB 读写磁盘和内存的基本单位。
  - 核心类型：  
    - 数据页：存储行记录
    - 索引页（B+树节点）：存储索引键和指针
    - Undo 页：存储 Undo Log
    - 系统页：存储元数据（如空间管理信息）

- **区**（Extent）
  - 连续页的集合：一个区包含 64 个连续的页（16KB × 64 = 1MB）。
  - 作用：
    - 减少随机 I/O：为表或索引预分配连续空间（例如 B+树扩展时直接分配一个区）。
    - 提升顺序访问性能。

- **段**（Segment）
  - 逻辑容器：一个段由多个区组成，用于管理特定类型的存储空间。
  - 常见段类型：  
    - 数据段：存储表数据（B+ 树的叶子节点）
    - 索引段：存储索引数据（B+ 树的非叶子节点）
    - 回滚段：存储 Undo Log

### 行记录

InnoDB 提供了 4 种行结构，分别是 Redundant、Compact、Dynamic 和 Compressed。其中 Redundant 已经不再使用，其他三种格式核心差异不大，主要是针对于溢出页的处理。

核心内容如下所示：

**辅助信息**

- 变长字段长度列表
  - 按照列的顺序，逆序存储变长列实际长度

- NULL 值列表
  - 对于存在允许 NULL 列的表，以二进制的方式逆序存储每个列的状态

- Header 信息（包括但不限于）
  - delete_mask：是否被删除
  - next_record：下一条记录的位置，指向辅助信息与数据信息之间的位置
    - 该指针所在位置，会导致辅助信息中的元素逆序存放的话，与位置靠前的列更靠近
  - record_type：如 0 表示普通记录，1 表示 B+ 树非叶子节点记录

**数据信息**

- 隐藏列数据
  - 行 ID `row_id`，针对没有主键或唯一列的表使用
  - 事务 ID `trx_id`，标识对应的事务
  - 回滚指针 `roll_pointer`，指向上一个事务版本

- 用户定义的列数据

- 溢出页指针，指向溢出页的地址
  - 对于 Compact 格式，当前数据列存储部分数据，剩余数据存放在溢出页
  - 对于 Dynamic 和 Compressed 格式，当前数据列仅存储溢出页指针

## 内存（Memory）

### Buffer Pool

Buffer Pool 是 InnoDB 的核心内存缓存区域，主要内容如下所示：

- **数据页**：缓存从磁盘加载的表数据页和索引页（B+树节点）
- **索引页**：缓存对非唯一索引的修改（INSERT/UPDATE/DELETE）
- **自适应哈希索引**：自动为频繁访问的索引页构建哈希索引，加速查询
- **锁信息**：行级锁、表级锁的元数据
- **Undo Log 页**：缓存 Undo Log 的修改，支持事务回滚和 MVCC
- **系统页**:- 存储空间管理信息（如区、段的分配状态）

在空间管理中，InnoDB 针对于每个缓存页都创建一个控制块，控制块信息包括缓存页的表空间、页号、缓存页地址、链表节点等，在内存分配上，控制块在最前面，缓存页在后面。

在 Buffer Pool 内部，根据缓存页中的数据版本，可分为空闲页、正常页与脏页，并通过三个链表来提高整体性能，链表中的节点存储来缓存页控制块的地址：

- **空闲页链表（Free 链表）**：当需要加载新的页面到 Buffer Pool 中，会从 Free 链表中找到一个空闲的缓存页进行写入，并从链表中移除
- **脏页链表（Flush 链表）**：当后台线程刷盘时，直接遍历 Flush 链表进行操作，刷盘后的脏页变为空闲页
- **LRU 链表**：同时包含正常页和脏页，提高缓存命中率，在页面置换时，将链表尾部的页面置换出去

### Buffer Pool LRU

常规的 LRU 算法，在 Buffer Pool 的场景下，面临两个额外问题：

**预读失效**

MySQL 在加载数据页时，会由于局部性原理，将相邻页一起加载进来，放到 LRU 链表头部，但是有可能这部分提前加载的数据页，永远不会被访问。

针对于此，MySQL 将 LRU 划分为两个区域：

- Young：存储频繁访问的热数据
- Old：存储新加载的冷数据

将预读的数据页放置在 Old 区域的首位，真正访问到时，再放置在 Young 区域首位。

**Buffer Pool 污染**

当某条 SQL 语句扫描了大量数据时，就有可能将目前中的数据页都置换出去，导致真正的热点数据被错误的替换出去。

针对于此，MySQL 把 Young 区域的准入门槛提高，增加了在 Old 区域的停留时长的判断：当 Old 区域中的数据被访问时，如果与首次访问的时间超过了一定间隔（`innodb_old_blocks_time`，默认 1000 ms），才会被插入到 Young 区域。

对于 Young 区域中的数据，为了避免头部数据频繁更改，只有当 Young 区域后 3/4 的数据被访问时，才会移动到链表头部，前 1/4 的数据被访问时，不会做修改。

### Redo Log Buffer & Binlog Cache

在事务执行时，Redo Log 会先写入内存中的 Redo Log Buffer，Binlog 会先写入内存中的 Binlog Cache，后续会依赖 Redo Log 和 Binlog 各自的刷盘策略，以及两阶段提交、组提交等策略持久化到磁盘中。

针对于 Redo Log Buffer 和 Binlog Cache，均没有显示的淘汰策略，具体的策略如下所示：

- **Redo Log Buffer**
  - **生命周期**：按事务提交顺序写入，刷盘后清理
  - **溢出管理**：当 Log Buffer 满 75% 时，后台线程强制触发刷盘策略

- **Binlog Cache**
  - **生命周期**：每个事务独占一个 Binlog Cache，提交后清空
  - **溢出处理**：空间不足，数据写入临时文件（磁盘），性能下降

## Ref

- [揭开 Buffer Pool 的面纱--小林coding](https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html)
