# MQ

## 基本概念

消息队列（Message Queue，MQ）是一种在分布式系统中用于**异步通信**的中间件技术。它通过**存储和转发消息**的方式，实现不同服务或组件之间的解耦、流量削峰、异步处理等目标，其相关概念如下所示：

- **消息（Message）**
  - 传递的数据单元，通常包含业务数据、元数据（如消息ID、时间戳）等
  - 消息根据实际需要，可分为普通消息、定时/延时消息、顺序消息、事务消息等

- **生产者（Producer）**
  - 负责创建并发送消息到 Broker 的服务或应用

- **消费者（Consumer）**
  - 从 Broker 中获取消息并进行处理的角色

- **队列（Queue）**
  - 存储消息的容器，遵循先进先出（FIFO）的规则，部分系统支持优先级
  - 用于**点对点模型**，即单播场景，多个消费者绑定同一个 Queue 时，消息会分摊给多个消费者
  - 不考虑优先级的场景下，同一队列的消息，天然有序，消息在队列中的位置通过 Offset 进行管理

- **主题（Topic）**
  - 消息传输和存储的顶层逻辑容器，内部由多个 Queue/Partition 组成
  - 用于**发布订阅模型**，即多播场景，绑定同一个 Topic 的多个消费者成为订阅者组，消息会发给所有消费者
  - 为数据隔离、订阅隔离、权限管控提供分类标识

- **消息中间件（Broker）**：
  - 消息队列的核心服务，负责接收、存储、路由和投递消息
  - 某些场景下还需要支持消费确认、发送确认等能力
  - Broker 可以看作一个消息队列的实例，多个 Broker 可以构成一个 Cluster（集群）
  - 一个 Broker 内部一般会包含多个 Topic/Queue

## 工作流程

### **生产者发送消息**

**创建消息**

- 生产者生成包含业务数据的消息

**选择目标 Queue/Topic**  

- 根据业务规则，将消息发送到指定的 Queue/Topic

**发送消息到 Broker**  

- 生产者通过协议将消息传输到 Broker

### **Broker 处理**

**接收消息**  

- Broker 验证消息格式和权限，确认生产者有权发送到目标队列

**存储消息**  

- **内存暂存**：高性能但可能丢失
- **磁盘持久化**：确保消息可靠性

**路由与分发**  

- **队列模式**：直接存储到指定队列
- **发布-订阅模式**：分发至指定的 Topic 中，并根据路由规则存储在指定的 Queue/Partition 中
  - **路由规则**：精准匹配、随机、优先级、负载均衡、时间窗口、关键字匹配、业务标签、条件匹配、广播等

**消息超时与重试**  

- Broker 可设置消息存活时间（TTL）
- 超时后移入死信队列（Dead-Letter Queue）或丢弃

### **消费者消费消息**

**订阅队列/主题**

- 消费者向Broker声明监听的队列或订阅的主题

**拉取消息（Pull）或推送消息（Push）**

- **Pull模式**：消费者主动从 Broker 拉取消息
- **Push模式**：Broker 主动将消息推送给消费者

**处理消息**

- 消费者根据获取的消息，执行业务逻辑

**消息确认（ACK）**

- **自动ACK**：Broker推送消息后立即标记为已消费（可能丢失消息）

- **手动ACK**：消费者处理完成后显式发送 ACK，Broker 删除消息
  - 若消费者处理失败或超时未 ACK，Broker 会将消息重新投递（可能引发重复消费）

**错误处理**

- **重试队列**：处理失败的消息进入重试队列，按策略重试
- **死信队列（DLQ）**：多次重试失败的消息进入死信队列，人工介入处理

## 使用场景

**异步**

- 将耗时操作异步化，避免同步阻塞

**接耦**

- 生产者与消费者通过 Queue/Topic 进行关联，无需直接耦合
- 新增或修改消费者，不影响生产者

**削峰**

- 突发流量下，MQ 作为缓冲区，服务根据实际能力去消费消息，避免过载

**最终一致性**

- 利用 MQ 实现 TCC、Sagas 等协议，并实现分布式场景下的事务一致性

**顺序消息**

- 保障生产者发送的消息，按照特定顺序被消费

**定时/延时消息**

- 消息发送后，在未来的一个时间点被消费

**数据流**

- 针对分布式系统的数据流，如业务日志、监控数据、用户行为等，通过 MQ 聚合到大数据平台

## 保障策略

### 服务质量

在保证消息一致性时，存在三种语义：

- **At Least Once**：最少一次。在消息队列中，指消息不丢失，一条消息最少被消费一次，但是可能会有重复消费
- **Exactly Once**：恰好一次。在消息队列中，消息被精准消费一次，不丢失，也不会重复
- **At Most Once**：最多一次。在消息队列中，消息不会被重复消费，但是可能会有消息丢失

可以看到，**Exactly Once** 的要求最高，既不能有重复消费，也不能有消息丢失，而对于其他两个语义，则分别在重复消费和消息丢失上做了妥协。

在实现上，MQ 对于生产者的幂等处理，以 Kafka 为例，需要以 Producer ID、Topic、Partition、Sequence Number 四个元素作为 Key 来判断，对于 Producer 重启（PID 更新）和多分区消息重试（Leader 切换但是 Seq Num 未同步）的场景，则无法继续保障幂等性。

所以，想要真正实现 **Exactly Once** 语义，则需要事务消息来保障跨会话、跨分区的原子性问题，会带来额外的性能开销。

从消费者角度考虑，大部分场景下本身也需要做幂等保证，**At Least Once** 即可满足诉求。对于对数据丢失容忍度更高的场景，比如非关键的实时监控和 UDP，也可以直接选择 **At Most Once**。

### 消息丢失

**生产者**

- **场景**：网络抖动或 Broker 宕机导致发送失败
- **解决方案**
  - 配置 `ACK` 和 `Retries` 策略，同步等待或异步回调进行处理
  - 对 `ACK` 超时或 `Retries` 超限的异常场景做兜底处理

**Broker**

- **场景**：未持久化时宕机导致内存数据丢失
- **解决方案**
  - 强化主备逻辑，当副本也同步收到消息时，才认为消息接收成功，但是只能降低消息丢失概率
  - 强化持久化逻辑，当持久化成功时，才认为消息接收成功，处理耗时会额外增加

**消费者**

- **场景**：自动提交 Offset 后处理失败
- **解决方案**
  - 关闭自动提交 Offset 的能力，消费完后手动提交
  - 如果消费后、提交前宕机，有可能导致重复消费

### 重复消费

**生产者**

- **场景**：Broker Ack 异常引发重试等原因导致重复发送
- **解决方案**
  - 通过 ProducerID 和 SequenceID 来标识消息，并在 Broker 做幂等判断
  - 无法保障全局幂等，仅能保障 Topic/Queue 级别幂等

**消费者**

- **场景**：消费完成后，提交 Offset 时失败，导致重复获取
- **解决方案**
  - 生产者额外给消息添加一个全局 ID（分布式 ID），消费者根据该 ID 做幂等

### 消息顺序

**生产者**

- **场景**：生产者并发发送导致消息乱序
- **解决方案**
  - **全局有序**：Topic 内采取单 Partition/Queue
  - **局部有序**：发送消息时，指定 Key 或者 Partition/Queue（相同的 Key 会分配至相同的 Partition/Queue）

**消费者**

- **场景**：消费者并发消费导致消息乱序
- **解决方案**
  - **单线程消费**：每个 Partition/Queue 分配独立单线程处理

### 消息堆积

- 消费速度快速下降：排查消费者异常
- 发送速度快速上升：
  - 排查生产者异常
  - 流量突发，临时扩容处理，或流量降级，非核心消息降级丢弃或转存死信队列
- 发送、消费速度无突变，逐渐积压：优化消费速度或扩容

### 死信队列

死信队列（Dead Letter Queue, DLQ） 是处理异常消息的核心机制，用于捕获无法被正常消费的消息，避免消息丢失或无限重试，当达到以下条件时，会将消息转发至死信队列中：

- 消费失败重试耗尽：消息被消费者多次重试后仍失败
- 消息过期（TTL）：消息或队列设置 TTL（Time-To-Live），超时未被消费
- 队列满或消息被拒绝：队列达到最大长度（x-max-length）或消费者主动拒绝（basic.reject）且不重新入队
- 路由错误：消息无法路由到任何队列

对于死信队列中的消息，需要采取特殊的消费策略，例如告警通知、延迟重试、消息补偿等。

## Ref

- <https://javaguide.cn/high-performance/message-queue/message-queue.html>
