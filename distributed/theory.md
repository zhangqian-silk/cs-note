# 分布式理论

## CAP

CAP 理论是分布式系统设计中的一个基础理论，由计算机科学家 Eric Brewer 在 2000 年提出，后由 MIT 的 Seth Gilbert 和 Nancy Lynch 在 2003 年通过形式化证明其正确性。

它描述了在分布式系统中，**一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）** 这三个核心特性之间的权衡关系。CAP 理论的核心结论是：在分布式系统中，这三个特性无法同时满足，最多只能满足其中两个。

### 核心特性

- **一致性（Consistency）**
  - 所有节点访问同一份最新的数据副本

- **可用性（Availability）**
  - 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）
  - 但是不保证获取的数据为最新数据

- **分区容错性（Partition Tolerance）**
  - 分布式系统出现网络分区的时候，仍然能够对外提供服务

### 网络分区

网络分区（Network Partition） 是分布式系统中一种常见的故障场景，指系统中的节点因网络故障被分割成多个独立子集，子集之间无法正常通信。需要注意的是，网络分区是分布式系统中的“常态”，必须充分考虑其影响以及应对策略。

- **网络分区原因**

  - 硬件故障  
    - 网络设备故障：网线、光纤损坏、路由器等
    - 服务器故障：电源、硬盘、内存等

  - 软件与协议问题  
    - 网络配置错误：防火墙规则错误、IP 冲突等
    - 网络协议故障：TCP/UDP 连接超时或丢包、DNS 解析失败等

  - 网络拥塞或延迟  
    - 心跳检测超时导致误判下线：网络负载高、跨地域延迟高、DDos 攻击等

<br>

- **网络分区的影响**

  - 一致性（C）与可用性（A）的冲突
    - 选择一致性（CP）：暂停部分服务，等待分区恢复，可能导致可用性下降。
    - 选择可用性（AP）：允许不同分区独立运行，但可能产生数据不一致。

  - 典型问题
    - 脑裂问题：多个分区各自选举出主节点，导致数据冲突。
    - 数据丢失风险：分区恢复后，若未正确处理冲突数据，可能覆盖正确结果。
    - 服务不可用：某些客户端可能因无法连接到指定分区而请求失败。

<br>

- **应对策略**

  - 预防措施
    - 使用多网卡、多交换机、多运营商链路，降低单点故障风险
    - 通过定期心跳包检测节点存活状态
    - 设置合理的超时时间，避免因短暂延迟误判为分区

  - 分区发生时的处理
    - 主节点选举：通过共识算法（如 Raft、Paxos）确保同一时刻只有一个主节点
    - 限流与熔断：拒绝部分请求以保护系统核心功能（如熔断器模式）
    - 客户端重定向：将请求引导至可用分区（如 DNS 切换、负载均衡策略）

  - 分区恢复后的处理
    - 数据合并：使用版本号（Vector Clock）、冲突解决算法（CRDTs）或人工干预修复数据
    - 状态同步：通过日志回放（WAL）或快照（Snapshot）恢复一致性

### **权衡**

由于网络分区的不可预测性，实际系统设计中必须优先保证分区容错性（P），因此真正的权衡在于一致性（C）和可用性（A）之间的选择：

- **CP 系统（一致性 + 分区容错性）**  
  - 牺牲可用性以保证强一致性
  - 典型场景：金融交易、库存管理等需要强一致性的领域
  - 例子：ZooKeeper、HBase、传统关系型数据库（如 MySQL 集群模式）

- **AP 系统（可用性 + 分区容错性）**  
  - 牺牲一致性以保证高可用性，但最终可能达成一致性（最终一致性）
  - 典型场景：社交网络、实时推荐系统等高并发场景
  - 例子：Cassandra、DynamoDB、Redis

- **CA 系统（一致性 + 可用性）**  
  - 牺牲分区容错性，仅在无网络分区的环境中有效（如单机或本地网络）
  - 局限性：在广域网或大规模分布式场景中不适用

## BASE

BASE 理论是 CAP 理论的延伸，也可看做是对于 AP 系统的补充，其核心在于牺牲一致性来满足系统的可用性，但是要保持最终一致性。

### 核心特性

- **基本可用（Basically Available）**

  - 系统在出现部分故障（如网络分区、节点宕机）时，仍能提供有限的功能，而非完全不可用
  - 实现方式
    - 服务降级：优先保障核心功能（如电商平台的交易功能），非核心功能（如商品推荐）可暂时关闭
    - 流量削峰：通过限流、排队或返回缓存数据，延迟响应时间，避免系统过载崩溃
  - 示例
    - 双十一期间，支付宝可能暂时关闭余额宝查询功能，但支付功能仍可用
    - 主从架构下，主节点故障时，由从节点提供读服务
    - 集群架构下，单个分片故障时，不影响其他节点

<br>

- **软状态（Soft State）**

  - 系统中的数据状态允许存在中间不一致性，且不影响系统的整体可用性
  - 特点
    - 无需实时同步：节点间的数据同步可以异步进行
    - 允许暂时冲突：例如，两个用户同时编辑文档，系统先保存各自版本，稍后合并冲突
  - 示例
    - 数据库的主从节点间，版本可能暂时不一致
    - Git 版本控制，开发者本地提交为软状态，后续同步远端更新并解决冲突后，才能推送

<br>

- **最终一致性（Eventual Consistency）**

  - 若系统不再有新数据写入，经过一段时间后，所有节点的数据最终会达成一致
  - 关键机制
    - 异步复制：数据变更通过消息队列或 Gossip 协议传播
    - 冲突解决：使用版本号、时间戳或业务规则合并冲突
  - 示例
    - 电商平台的“库存超卖”，允许订单创建时短暂超卖，后续通过补货或取消订单修复
    - DNS 系统的全球解析更新可能延迟数小时，但最终一致

## 一致性

分布式场景下，针对于一致性模型，可分为强一致性（Strong Consistency）、弱一致性（Weak Consistency）和最终一致性（Eventual Consistency），定义了数据在多节点间的同步规则。

### 强一致性（Strong Consistency）

强一致性要求所有节点在任何时刻读取的数据都是最新的，即牺牲可用性（A）以保证一致性（C），属于 CAP 理论中的 CP 系统。

- **技术实现**
  - 分布式锁：写入时锁定所有相关节点，确保数据同步完成前禁止读取
  - 两阶段提交（2PC）：通过协调者确保所有节点事务提交或回滚
  - 共识算法：如 Raft、Paxos，强制多数节点达成一致后才响应客户端

<br>

- **示例**  
  - 金融：银行转账、股票交易
  - MySQL 主从同步（半同步模式）：主库写入后，至少一个从库确认收到日志才返回成功
  - ZooKeeper：通过 ZAB 协议保证所有节点数据强一致

### 弱一致性（Weak Consistency）

系统不保证数据的实时同步，允许点间存在不一致的中间状态，即允许读取到旧数据。优先保证可用性（A），属于 CAP 理论中的 AP 系统。

- **技术实现**  
  - 异步复制：写入主节点后，异步传播到从节点
  - 客户端缓存：允许客户端读取本地缓存的历史数据
  - 无锁设计：放弃全局锁，允许多节点并行写入

<br>

- **示例**
  - Redis 主从异步复制：主节点写入后立即返回，从节点数据可能延迟同步
  - 浏览器缓存：用户可能看到过期的静态页面版本
  - 近似统计：视频播放量、点赞量

### 最终一致性（Eventual Consistency）

保证在没有新写入操作的情况下，经过一段时间后，所有节点的数据最终一致，通过异步同步机制在可用性（A）和一致性（C）之间折中，属于 BASE 理论的核心原则。

- **技术实现**
  - Gossip 协议：节点间随机交换数据，逐步收敛到一致状态
  - 版本向量（Version Vectors）：记录数据版本，解决冲突合并
  - CRDTs（无冲突复制数据类型）：设计数据结构自动合并冲突

<br>

- **示例**  
  - 在线云文档：多人可以同时编辑，冲突能够自动合并
  - 分布式数据库：Redis 集群

### 因果一致性（Causal Consistency）

保证有因果关系的操作在分布式系统中的顺序一致性，无因果关联的操作允许乱序。例如，用户 A 发帖后用户 B 回复，所有节点必须按“发帖→回复”顺序呈现，但无关操作（如用户C的点赞）可以异步同步。

- **技术实现**  
  - 向量时钟（Vector Clocks）：追踪事件因果关系，通过时间戳向量标记操作顺序  
  - 因果日志（Causal Logging）：记录操作依赖关系，确保因果链在节点间同步  
  - 序列化冲突检测：对存在因果关联的写入进行顺序校验  

<br>

- **示例**  
  - 分布式社交网络：用户评论和回复的依赖关系必须严格有序  
  - Apache Cassandra：支持轻量级因果一致性的事务操作  
  - 分布式协作工具：如 Slack 消息的线程依赖需按顺序显示  

### 会话一致性（Session Consistency）

保证同一会话（Session）内的读写操作顺序一致，用户在一个会话中能读取到自己最近的写入，但不同会话之间可能短暂不一致。例如，用户修改个人资料后，在本会话中立即生效，其他用户可能稍后才能看到。

- **技术实现**  

  - 粘性会话（Sticky Session）：将同一用户请求路由到固定节点，保证读写路径一致  
  - 版本令牌（Version Token）：客户端携带令牌标识最新写入版本，服务端校验一致性  
  - 本地副本同步：在会话生命周期内，优先读取本地已同步的副本  

<br>

- **示例**  
  - 购物车系统：用户添加商品后，同一会话内始终显示最新购物车状态  
  - 用户配置管理：修改设置后，本会话内立即生效，其他设备异步同步  
  - 分布式缓存（如Memcached）：通过会话绑定实现短期内的读写一致性  

### 读写一致性（Read-Write Consistency）

确保客户端在写入后，后续读操作能立即获取最新数据，分为单调读（Monotonic Reads）和单调写（Monotonic Writes）两种模式。例如，用户发布文章后，刷新页面必须看到新内容，但其他用户可能延迟看到。

- **技术实现**  
  - 写后读主库（Read-After-Write）：写入主库后，强制后续读操作走主库而非从库  
  - 时间戳追踪：为每个写入分配全局时间戳，读取时过滤未同步的旧数据  
  - 客户端缓存标记：在客户端记录最新写入时间，请求时携带该标记强制更新  

<br>

- **示例**  
  - 数据库读写分离：MySQL主从架构中，用户写操作后自动路由读请求到主库  
  - 社交媒体发帖：用户发布动态后，立即在自己的时间线中可见  
  - 分布式文件存储（如AWS S3）：上传文件后，通过重定向确保读取最新版本  

## Ref

- [wiki/CAP定理](https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86)
- <https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html>
