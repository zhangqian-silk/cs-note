# 正则表达式

## 前言

内容整体偏短，适合于新手想要快速掌握正则表达式中的语法知识，以及复习、回顾时查阅，遇到暂不熟悉的字符，推荐继续向后阅读，或结合百度使用。

## 简介

简单来说，正则表达式是一种用来匹配和处理文本的字符串。例如用来匹配文本中是否包含特定的字符串，校验文本是否满足特定的条件，按条件批量替换文本信息，获取特定的分组结果，等等。

正则表达式使用正则表达式语言来构建，有自己独特的语法。不过正则表达式语言并非是一种程序设计语言，从个人角度来看，类似于数学表达式。例如当我们给定 $f(x)=x^2$ 时，我们会明确知道这个表达式的运算规则，那么当我们给定 `[0-9]` 时，我们也会同样明确清楚这个正则表达式的匹配规则（表示匹配一个数字）。同时，正则表达式也像数学表达式一样，支持任意规则的随意组合。

目前，在绝大多数的语言以及计算相关的平台中，均支持正则表达式，当处理较为复杂的字符串相关的逻辑时，我们应当首先考虑使用正则表达式来辅助我们实现需求。

## 普通字符

普通字符包含了所有未被指定为元字符（后文会介绍）的字符，例如数字 `0-9`，字母 `a-z` 与 `A-Z`，当然也可以通过 Unicode 用于匹配汉字，例如 `[\u4e00-\u9fa5]` 包含了约 2w 个汉字，基本覆盖了所有常用的简体与繁体字符。此外，普通字符也包含了非打印字符，例如常见的换行符 `\n`，制表符 `\t` 等等。

当我们在使用普通字符构造正则表达式时，看上去就像是纯文本，但他的确是正则表达式的一种。例如：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `#FF0000` | 红色可表示为 **#FF0000** |
| `绿色` | **绿色**可表示为 #FF0000 |

## 元字符

元字符是指在正则表达式中具有特殊含义的字符，代表了正则表达式中的特殊语法，而非其字面意思。通过这些元字符，我们可以大大拓展正则表达式的匹配规则，而非上文中仅匹配纯文本信息。常见的元字符如 `*` 匹配任意数量的元素， `{n}` 匹配 n 次，`[xyz]` 匹配一组元素中任意一个。

当我们将元字符与普通字符结合时，就可以构造出我们想要的任何字符串的正则表达式了。同样以上面的例子为例，此处我们将匹配任意的符合 RGB 规范的字符串，以及匹配所有满足需求的颜色：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `#[0-9a-fA-F]{6}` | 红色可表示为 **#FF0000** |
| `[红橙黄绿青蓝紫]色` | **绿色**可表示为 #FF0000 |

- `#[0-9a-fA-F]{6}` 表示匹配一个 `#` 开头，后面紧跟着六位合法的 16 进制字符的字符串，其中 `[0-9a-fA-F]` 表示匹配 (0123456789AaBbCcDdEeFf) 中的任意一个，`{6}` 则表示重复 6 次。
- `[红橙黄绿青蓝紫]色` 表示匹配彩虹色中的任意一种，即红色、橙色、黄色、绿色、青色、蓝色、紫色中的任意一种。

### 转义

如前文所提到的，元字符在正则表达式中，会有着特殊含义，例如 `*` 可用来匹配任意个字符，所以这些字符在正则表达式中无法匹配他们自身。例如 `0*`，会被用来匹配任意个连续的 `0`，而非字符 `0*` 本身。

通过元字符 `\`，我们可以改变紧随其后的字符的含义。对于表达式 `\*`，可以将 `*` 从元字符变为普通字符，进而就可以用来匹配 `*` 字符本身了。例如：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `0*` | **000000**\* |
| `0\*` | 00000**0\*** |

当然，`\` 本身也是元字符的一种，想要匹配 `\` 本身，同样需要进行转义，即使用 `\\` 来匹配。

除了将一个特殊字符标记为普通字符以外，转义也会用于将普通字符标记为特殊字符，如换行符 `\n`，制表符 `\t` 等等。

### 字符集合

在某些场景下，我们要匹配的目标可能是一系列值中的某一个，而非是某个特定的字符串，此时我们可以使用字符集合来表示匹配集合中的任意一个字符，字符集合使用 `[xyz]` 来表示，其中 `[` 与 `]` 仅用来定义一个集合，不会匹配任何字符，`xyz` 代表将匹配 `x`、`y` 与 `z` 三个字符中的任意一个。例如：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `[mMnN]` | **M**o**n**day |
| `[mn]` | Mo**n**day |

#### 字符区间

在某些常见下，我们所选用的字符集合，会具备明显特征，如数字集合 `[0123456789]`、小写字母集合 `[abc...xyz]`、大写字母集合 `[ABC...XYZ]` 等等。为了简化这种有明显规律性的集合定义，正则表达式提供了一个特殊的连字符 `-` 来简化定义。上述所提到的集合，可简化为 `[0-9]`、`[a-z]` 与 `[A-Z]`。

对于熟悉 ASCII 与 Unicode 的读者可以发现，上面所提到的 `0-9` 、`a-z` 与 `A-Z` 均符合 Unicode 中的编码顺序，而这也正是连字符所发挥的作用，用于匹配两个指定的 Unicode 字符之间的所有字符（闭区间）。所以当我们想要匹配所有字母时，必须指定为 `[a-zA-Z]`，而不能指定为 `[A-z]`，因为这会包括 `Z` 与 `a` 之间的某些字符，如 `[` 和 `^` 等。同样，我们还可以利用这一特性，去匹配某一特定的字符集合，如 `[\u4e00-\u9fa5]` 用于匹配常见汉字，`[\u0370-\u03FF]` 用于匹配所有小写希腊字母。

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `[024]` | 手机号：1881**2**3**4**5678  |
| `[5-8]` | 手机号：1**88**1234**5678**  |

#### 取反

对于字符集合来说，可以指定一组用来匹配的字符，但是某些场景，会需要我们去指定一组不希望匹配到的字符，比如在选择手机号的时候，可能不希望带有数字 `4` 和 `7`。这时候，可以使用元字符 `^`，表明对于字符集合进行取反匹配。例如：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `[^47]` | **手机号：188123**4**56**7**8**  |
| `[47]` | 手机号：188123**4**56**7**8  |

#### 取或

与字符集合一个比较类似的概念，是“或”操作，即可以是字符串 `aaa`，也可以是字符串 `bbb`，同样声明了一个集合。例如

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `19` | **19**88，2045，1270，1022 |
| `19\|20` | **19**88，**20**45，1270，1022  |

#### 字符类别

对于常用的字符集合，如 `[0-9]`，`[a-z]` 等，正则表达式中还提供了特殊的元字符来进行表示，如：

- `\d` 匹配一个数字，等价于 `[0-9]`；
- `\D` 匹配一个非数字，等价于 `[^0-9]`；
- `\w` 匹配任何一个字母、数字和下划线字符，等价于 `[0-9a-zA-Z_]`；
- `\W` 匹配任何一个非字母、数字和下划线字符，等价于 `[^0-9a-zA-Z_]`；
- `\s` 匹配一个空白字符，等价于 `[\f\n\r\t\v]`；
- `\S` 匹配一个非空白字符，等价于 `[^\f\n\r\t\v]`

此外，还有一个极其特殊的元字符 `.`，可以用来匹配任意内容。

#### 特殊字符

字符集合首先由两个元字符 `[` 和 `]`进行定义，在字符集合中，我们可以使用 `-` 来表示字符区间，或者使用 `^` 来进行取反匹配。此外，转义字符 `\` 也是在字符集合中会被使用到的一种元字符，用来转义 `-` 与 `^`，或是用来转义特殊的普通字符，如 `\n` 和 `\t` 等。

但是对于其他元字符，例如 `.` 和 `*`，在字符集合中，仅表现为普通字符。这种语法也很自然，对于符号 `.`，其本身就发挥了字符集合的作用，而对于 `*`，字符集合仅是一个集合，其实际匹配的还是单个字符，想要 `*` 发挥作用，应该与其他字符类似，紧跟在字符集合之后，例如 `[0-9]*`。

### 数量匹配

在实际匹配中，所匹配字符的数量，往往也是重要的匹配条件之一，例如合法的手机号应该是 13 位数字（国内），合法的身份证号应该是 18 位数字，且可能包含字母 X，等等。如下的元字符可以帮助我们去限定字符的数量规则：

- `*`：匹配任意数量字符；
- `?`：匹配 0 位或 1 位字符；
- `+`：匹配 1 位或更多位字符；
- `{n}`：匹配 n 位字符；
- `{m,n}`：匹配 `[m,n]` 位字符，即匹配 m，m+1, m+2,..., n 位，范围为闭区间；
- `{m,}`：匹配 `[m, ∞)` 位字符，即最少匹配 m 次；

显然，`*` 等价于 `{0,}`，`?` 等价于 `{0,1}`，`+` 等价于 `{1,}`，简单举例如下：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `\(\+86\)*[0-9]*` | 测试文本为 **(+86)(+86)1234**，**(+86)1234** 和 **1234** |
| `\(\+86\)?[0-9]*` | 测试文本为 (+86)(+86)1234，**(+86)1234** 和 **1234** |
| `\(\+86\)+[0-9]*` | 测试文本为 **(+86)(+86)1234**，**(+86)1234** 和 1234 |

#### 过度匹配

在刚才的介绍中，我们已经看到了 `*` 字符的威力，他会匹配所有他能到匹配到的内容，但有时候会过于强大。以 `HTML` 文本为例，当我们想要从一串 `HTML` 文本中匹配到所有段落时，首先找到这串文本的特征：以 `<p>` 开头，以 `</p>` 结尾，其中可以包含任意字符（忽略其中的文本是否满足 `HTML` 语法），很自然的，我们会给出如下示例：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `<p>.*</p>` | **\<p\>Test\<\/p\>** |

看上去似乎可以充分满足诉求，但是很不幸，以上示例并不总能正确工作。比如如下示例：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `<p>.*</p>` | **\<p\>Test1\<\/p\> xxx \<p\>Test2\<\/p\>** |

可以发现，在这串字符中，我们只找到了一处匹配，原因是在第一个 `<p>` 与最后一个 `</p>` 之间的所有内容，即 `Test1</p> xxx <p>Test2` 这部分，会全部被 `.*` 所匹配，而并非所认为的，遇到第一个 `</p>` 就会结束一次匹配，并开始寻找下一个满足条件的匹配结果。

换句话说，`*` 字符在进行匹配时，会尽可能的匹配所有内容，多多益善，也就是所谓的“贪婪型”元字符。与之相对的，可以使用“懒惰型”字符，这些字符在匹配时，会适可而止，碰到第一次满足条件的匹配时，就会结束当次的匹配行为。常见的对应关系如下：

| “贪婪型”元字符 | “懒惰型”元字符 |
| ---- | ---- |
| `*` | `*?` |
| `+` | `+?` |
| `{n,}` | `{n,}?` |

当我们使用“懒惰型”元字符时，上述的正则表达式匹配结果如下：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `<p>.*?</p>` | **\<p\>Test1\<\/p\>** xxx **\<p\>Test2\<\/p\>** |

### 边界匹配

对于字符串的匹配规则，可能还会有位置的强校验，例如当我们校验某段字符串，是否是 `HTML` 文本时，可能会有明确的格式匹配要求，以 `<html>` 开头，并且以 `</html>` 结尾。如下的元字符可以帮助我们去限定字符的边界信息：

- `\b`：匹配一个单词的开始或结尾。
- `\B`：匹配一个非单词边界。
- `^`：匹配字符串开头。
- `$`：匹配字符串结尾。

其中 b 是英文boundary（边界）的首字母，但是正则表达式的引擎并非是万能的，并非是真正识别出一个单词边界，而是匹配能够构成合法单词的字符和不能构成合法单词的字符之间，也即 `\w` 和 `\W` 之间的位置。

对于几种场景，举例如下：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `cat` | Test: **cat**, **cat**egory, copy**cat**. |
| `\bcat` | Test: **cat**, **cat**egory, copycat. |
| `cat\b` | Test: **cat**, category, copy**cat**. |
| `<html>.*?</html>` | This is HTML example: **\<html\>xxx\</html\>**. |
| `^<html>.*?</html>&` | This is HTML example: \<html\>xxx\</html\>. |
| `<html>.*?</html>` | **\<html\>xxx\</html\>** |
| `^<html>.*?</html>&` | **\<html\>xxx\</html\>** |

对于边界匹配的元字符，可以看作是一种特殊字符，其代表了特殊的边界。从效果上来看，`^xxx` 和 `yyy$` 分别匹配以 xxx 开头和以 yyy 结尾的字符串，可以认为是对于一个完整的字符串来说，例如 `abcdcda`，在正则表达式中，其实可以看作是 `^abcdcda$`，此时对于 `a` 和 `^a` 能够匹配到的信息，一目了然了：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `a` | **a**bcdcd**a** |
| `^a` | **a**bcdcda |

### 子表达式

在正常模式下，我们所使用到的数量匹配的元字符，仅会作用于紧跟着元字符的前一个字符，即使是字符集合，实际上也是单个字符。此时可以通过元字符 `(` 和 `)`，构造一个子表达式，使得其他原本作用于单个字符的元字符，可以扩大作用范围。例如：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `[0-9]{1,3}` | IP: **192**.**168**.**1**.**1** |
| `[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}` | IP: **192.168.1.1** |
| `([0-9]{1,3}\.){3}[0-9]{1,3}` | IP: **192.168.1.1** |

此外，和其他场景类似的，元字符也会有优先级的概念，这部分内容也可以使用 `()` 来进行改变，类似于数学表达式中，$(1+2)*3$ 与 $1+2*3$ 的差异。例如：

| 正则表达式 | 文本匹配结果 |
| ---- | ---- |
| `19\|20[0-9]{2}` | **19**88，**2045**，1270，1022 |
| `(19\|20)[0-9]{2}` | **1988**，**2045**，1270，1022  |

预期的匹配目标，是 1900 ～ 2099 之间的年份，但是对于正则表达式 `19\|20[0-9]{2}`，实际含义是匹配 `19` 或者匹配 `20[0-9]{2}`

## 附录

### 非打印字符

| 字符 | 描述 |
| ---- | ---- |
| \\cx | 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \\f | 匹配一个换页符。等价于 \\x0c 和 \\cL。 |
| \\n | 匹配一个换行符。等价于 \\x0a 和 \\cJ。 |
| \\r | 匹配一个回车符。等价于 \\x0d 和 \\cM。 |
| \\s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 |
| \\S | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 |
| \\t | 匹配一个制表符。等价于 \\x09 和 \\cI。 |
| \\v | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 |

### 元字符

| 字符 | 描述 |
| --- | --- |
| \\ | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。 |
| ^ | 匹配输入字符串的开始位置。 |
| $ | 匹配输入字符串的结束位置。 |
| * | 匹配前面的子表达式零次或多次。 |
| + | 匹配前面的子表达式一次或多次。 |
| ? | 匹配前面的子表达式零次或一次。 |
| {n} | n 是一个非负整数。匹配确定的 n 次。 |
| {n,} | n 是一个非负整数。至少匹配n 次。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。 |
| ? (后缀) | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。 |
| . | 匹配除 "\n" 之外的任何单个字符。 |
| (pattern) | 匹配 pattern 并获取这一匹配。 |
| (?:pattern) | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。 |
| (?=pattern) | 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。 |
| (?!pattern) | 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。 |
| x&#124;y | 匹配 x 或 y。 |
| [xyz] | 字符集合。匹配所包含的任意一个字符。 |
| [^xyz] | 负值字符集合。匹配未包含的任意字符。 |
| [a-z] | 字符范围。匹配指定范围内的任意字符。 |
| [^a-z] | 负值字符范围。匹配任何不在指定范围内的任意字符。 |
| \b | 匹配一个单词边界，也就是指 \w 和 \W 之间的位置。 |
| \B | 匹配非单词边界。 |
| \cx | 匹配由 x 指明的控制字符。 |
| \d | 匹配一个数字字符。 |
| \D | 匹配一个非数字字符。 |
| \f | 匹配一个换页符。 |
| \n | 匹配一个换行符。 |
| \r | 匹配一个回车符。 |
| \s | 匹配任何空白字符，包括空格、制表符、换页符等等。|
| \S | 匹配任何非空白字符。 |
| \t | 匹配一个制表符。 |
| \v | 匹配一个垂直制表符。 |
| \w | 匹配包括下划线的任何单词字符。 |
| \W | 匹配任何非单词字符。 |
| \xn | 匹配 n，其中 n 为十六进制转义值。 |
| \num | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。 |
| \n | 标识一个八进制转义值或一个向后引用。 |
| \nm | 标识一个八进制转义值或一个向后引用。 |
| \nml | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| \un | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。 |
