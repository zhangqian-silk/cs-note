# TCP

TCP（Transmission Control Protocol，传输控制协议）是互联网核心协议之一，属于传输层协议，提供**面向连接、可靠的、基于字节流**的数据传输服务，常用于 `FTP`、`HTTP/HTTPS` 等场景。

UDP（User Datagram Protocol）同样也是传输层协议，相比与 TCP，其是面向无连接的，处理逻辑简单，性能高，常用于 `DNS`、`SNMP` 等数据量较少或是音视频等对延迟敏感、丢包容忍度高的场景。

## 核心特性

**面向连接**

- 通信前需通过**三次握手**建立连接，通信后通过**四次挥手**释放连接。
- 确保双方准备好数据传输。

**可靠性保障**

- **确认应答（ACK）**：接收方收到数据后发送确认信号
- **超时重传**：未收到 ACK 时，发送方重传数据
- **序列号与确认号**：标识数据顺序，解决乱序、重复问题

**流量控制**

- 通过**滑动窗口机制**动态调整发送速率，防止接收方缓冲区溢出

**拥塞控制**

- 算法包括**慢启动、拥塞避免、快速重传、快速恢复**，避免网络过载

**全双工通信**

- 双方可同时发送和接收数据

## 报文格式

![](images/2025-03-29-15-59-58.png)

- **源端口/目的端口**：标识应用程序，结合源 IP/目标 IP，确定一条连接
- **序列号**：建立连接时随机生成，标识当前数据字节的起始位置
  - 解决网络包乱序问题
  - 检测重复或丢包问题
- **确认应答号**：接收方期望的下一个字节的序列号，用于确认已接收的数据
  - 解决丢包问题
  - 推动滑动窗口
- **标志位**
  - `SYN`：建立连接，并初始化序列化
  - `ACK`：确认应答，除最初的 `SYN` 以外，必须设置为 1
  - `FIN`：终止连接
  - `RST`：重置连接
- **窗口大小**：接收方可接收的数据量

## 连接管理

**三次握手**

![](images/2025-03-29-19-19-18.png)

- **步骤**：
  1. 客户端发送 `SYN=1, seq=x`（同步请求）
  2. 服务端回复 `SYN=1, ACK=1, seq=y, ack=x+1`
  3. 客户端发送 `ACK=1, seq=x+1, ack=y+1`
- **目的**：
  - 协商初始序列号
  - 确认双方收发能力正常
  - 阻止历史连接的初始化，避免资源浪费

**SYN Flood 攻击**

正常流程下，当接收到 `SYN` 报文时，会创建一个半连接对象并将其添加至 `SYN` 队列种，接收到 `ACK` 报文后，才会将其放入 `Accept` 队列，等待应用获取。

![](images/2025-03-29-22-01-50.png)

如果攻击者只发送 `SYN` 报文，而不发送 `ACK` 报文，即 **SYN Flood 攻击**，会迅速把半连接队列占满，从而导致正常的请求也无法建立连接。

其主要解决方案为启用 **SYN Cookie**。在这种情况下，如果 `SYN` 队列已满，后续收到的 `SYN` 报文不会直接丢弃，而是计算出一个 `cookie` 值放在响应的序列号中，后续接收到 `ACK` 报文后，通过验证 `cookie` 来判断其合法性。

**四次挥手**

![](images/2025-03-29-19-51-44.png)

- **步骤**：
  1. 主动方发送 `FIN=1, seq=u`（终止请求）
  2. 被动方回复 `ACK=1, seq=v, ack=u+1`
  3. 被动方发送 `FIN=1, ACK=1, seq=w, ack=u+1`
  4. 主动方回复 `ACK=1, seq=u+1, ack=w+1`，并等待 2MSL 后关闭
  5. 被动方收到 `ACK` 后立即关闭
- **目的**：
  - 需双方分别关闭发送和接收通道
  - 主动方最后等待 2MSL 是为了当最后一次 `ACK` 丢失，被动方触发超时重传时，主动方可以正常响应 `ACK`
- **特殊场景**：
  - 当超时重试达到最大次数时，会触发超时关闭，强制断开连接
  - 当触发延迟确认逻辑时，被动方的 `ACK` 和 `FIN` 可能一起发送，变为三次挥手

## 可靠传输机制

**序列号与确认号**

对于每个请求，都会携带序列号与确认号，以保障字节流有序，避免乱序问题，同时检测出丢包、重复发送等问题。

在请求交互中，序列号与确认号的规则如下：

- **序列号**：上一次发送的序列号 + 数据长度
- **确认号**：上一次收到的序列号 + 数据长度
- 当请求不携带数据时
  - 对于 `SYN` 或 `FIN` 报文，认为数据长度为 1，因为其是控制标识，需要被占用序列号以保障被可靠确认
  - 对于 `ACK`、`RST` 等报文，序列号不变，相对于的接收方的确认号也不变

**延迟确认**

![](images/2025-03-29-20-32-19.png)

为了解决只发送 `ACK` 导致的传输效率低的问题，引入了延迟确认逻辑，其核心目标是尽量合并确认，减少不必要的 `ACK` 发送，其实现如下：

- 当有响应数据要发送时，`ACK` 会和数据一起发送
- 当没有响应数据要发送时，`ACK` 会延迟一段时间，以等待可能到来的影响数据并一起发送
- 在延迟期间，收到了第二个数据请求，会根据具体实现，重置 `ACK` 的确认号并重置定时器，或立即发送
- 在延迟期间，收到乱序报文或涉及窗口大小更新，会立即发送

**超时重传（RTO）**

- 动态计算超时时间（基于RTT，即数据往返时间）。

**滑动窗口**

- 发送窗口：允许未确认的最大数据量。
- 接收窗口：缓冲区剩余空间，通过ACK告知发送方。

## 拥塞控制算法

**慢启动（Slow Start）**

- 窗口从1开始，每RTT指数增长（如1, 2, 4, 8...）。

**拥塞避免（Congestion Avoidance）**

- 窗口达到阈值后，每RTT线性增长（如+1）。

**快速重传与快速恢复**

- 收到3次重复ACK时，立即重传丢失报文，避免等待超时。

### **八、常见问题**

1. **粘包问题**  
   - 数据边界不清晰，需应用层协议自行处理（如添加长度字段）。

## Ref

- <https://xiaolincoding.com/network/3_tcp/tcp_interview.html>
- <https://xiaolincoding.com/network/3_tcp/tcp_seq_ack.html>
- <https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html>
