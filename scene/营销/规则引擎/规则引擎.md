# 规则引擎

## 1. 概述

在数字化营销系统中，**规则引擎 (Rule Engine)** 是将业务决策逻辑（Business Logic）与系统核心代码（System Code）解耦的关键组件。它允许业务运营人员通过图形化界面或领域特定语言（DSL）动态配置营销策略，而无需等待研发发版，从而实现营销活动的敏捷迭代。

核心价值：

- **解耦**：业务逻辑独立于应用程序代码。
- **敏捷**：支持热部署，策略变更秒级生效。
- **透明**：逻辑可视化，便于业务理解和管理。

---

## 2. 核心业务场景

营销系统中的规则引擎主要应用于“判断”与“计算”两大类场景。

### 2.1 活动准入与人群圈选 (Eligibility & Segmentation)

判断用户是否有资格参与某个活动或被划分为某类人群。

- **场景示例**：
  - "仅限注册时间在 30 天内的新用户参与"。
  - "过去 7 天在美妆类目消费超过 500 元的女性用户"。
  - "位于'北京'且当前设备为'iOS'的用户"。
- **逻辑特征**：主要涉及布尔逻辑运算（AND, OR, NOT）和比较运算（>, <, =, IN）。

### 2.2 权益发放与计算 (Benefit Distribution)

根据用户行为和属性，计算应发放的奖励类型及数量。

- **场景示例**：
  - **阶梯满减**：满 100 减 10，满 200 减 30，满 500 减 100。
  - **组合优惠**：购买 A 商品 + B 商品，B 商品打 5 折。
  - **随机红包**：根据用户等级（L1-L5），发放 [1.0, 5.0] 区间的随机金额红包，L5 用户获得大额概率更高。
- **逻辑特征**：涉及复杂的算术运算、条件分支（If-Then-Else）及概率计算。

### 2.3 动态定价与折扣 (Dynamic Pricing)

实时计算商品的最终成交价。

- **场景示例**：
  - 会员专享价：金牌会员 95 折，钻石会员 88 折。
  - 促销叠加：单品直降 + 平台券 + 支付优惠的叠加逻辑及互斥校验（如“不可与满减券同享”）。
- **逻辑特征**：涉及复杂的优先级排序（Priority）、互斥逻辑（Mutex）及高精度的浮点运算（Decimal）。

### 2.4 营销风控 (Risk Control)

在营销链路中实时拦截异常行为。

- **场景示例**：
  - **频次控制**：单用户单日领取优惠券不超过 3 张。
  - **黑名单拦截**：用户 ID 或设备指纹在黑名单中，直接拒绝。
  - **行为异常**：1 分钟内连续请求超过 60 次。
- **逻辑特征**：高并发下的实时计数（Sliding Window Counter）、黑名单匹配（Bloom Filter/Set）及异常检测。

### 2.5 任务与成就体系 (Gamification & Task System)

基于用户行为状态的累积与触发，实现“做任务-领奖励”的闭环。

- **场景示例**：
  - **累积型任务**：连续签到 7 天，额外奖励 100 积分。
  - **组合型任务**：完成“完善资料”且“首次下单”，解锁“新手勋章”。
  - **状态机流转**：用户从 L1 升级到 L2 时，自动发放升级礼包。
- **逻辑特征**：强依赖状态存储（Stateful），涉及时间窗口内的聚合计算（Count, Sum）及状态机变迁。

### 2.6 智能触达与消息路由 (Smart Touch & Message Routing)

决定在什么时间、通过什么渠道、向用户发送什么内容，以最大化点击率并降低打扰。

- **场景示例**：
  - **渠道路由**：优先发送 App Push；若用户未开启 Push 权限或 2 小时未读，则降级发送短信。
  - **疲劳度控制**：同一用户 24 小时内最多收到 2 条营销类消息。
  - **时机选择**：根据用户历史活跃习惯，预测其最可能打开 App 的时间段进行发送。
- **逻辑特征**：多条件分支路由（Switch-Case）、时间序列预测及流量控制（Rate Limiting）。

### 2.7 推荐干预与流量调控 (Recommendation Intervention)

**注**：此场景中，规则引擎通常作为“重排层 (Re-ranking Layer)”嵌入推荐系统，负责处理运营强规则和合规硬规则，是对推荐算法（千人千面）的补充。

- **场景示例**：
  - **强插/置顶**：大促期间，强制将“主会场入口”插入到 Feed 流的第 3 位。
  - **打压/降权**：评分低于 3.0 的商家，在推荐列表中权重降低 50%。
  - **多样性控制**：连续 5 个展示位中，不能出现同一类目的商品。
- **逻辑特征**：涉及对列表数据（List）的重排序（Re-rank）、过滤（Filter）和插入（Insert）。

### 2.8 售后与服务保障 (After-sales & Service)

**注**：此场景中，规则引擎通常作为“决策节点 (Decision Node)”嵌入工作流引擎 (Workflow Engine)，实现审批流程的自动化流转。

- **场景示例**：
  - **极速退款**：用户信用分 > 700 且退款金额 < 200 元，申请退款直接系统通过，无需人工审核。
  - **运费险赔付**：根据用户的收货地址与退货仓距离，自动计算应赔付的运费金额。
  - **自动赔付**：外卖订单超时 30 分钟，自动发放 5 元无门槛红包作为补偿。
- **逻辑特征**：涉及复杂的审批流（Workflow）、多数据源聚合（Data Aggregation）及置信度计算。

---

## 3. 技术架构设计

一个成熟的营销规则引擎不仅包含核心的计算模块，还涵盖了从规则配置到上线的完整生命周期管理。我们可以将系统划分为 **配置态 (Configuration Phase)** 和 **运行态 (Runtime Phase)** 两个阶段。

### 3.1 核心模块概览

| 模块 | 职责 | 关键技术实现思路 (后端) |
| :--- | :--- | :--- |
| **规则编辑器 (Editor)** | 供运营人员配置规则的 GUI 界面。支持决策树、决策表、自然语言 DSL。 | 前端组件 (React/Vue) + 后端 DSL 校验接口 |
| **规则仓库 (Repository)** | 存储规则元数据、版本管理、状态管理（草稿/发布/下线）。 | 关系型数据库 (MySQL) + 缓存 (Redis) |
| **规则编译器 (Compiler)** | 将前端配置的规则转化为机器可执行的代码或对象（AST/Plugin）。 | 词法分析 (Lexer), 语法分析 (Parser) -> AST |
| **执行引擎 (Runtime)** | 接收上下文数据 (Fact)，匹配规则，执行动作 (Action)。 | 解释器模式, 策略模式, Rete 算法 |
| **服务接口 (Service)** | 提供 RPC/HTTP 接口供上游业务调用。 | RPC, HTTP Framework |

### 3.2 全链路工作流

#### 3.2.1 配置态：从“视觉”到“结构化存储”

此阶段的目标是让非技术人员能够安全、准确地定义业务规则。

1.  **前端交互 (UI/UX)**：
    运营人员在可视化界面上进行操作。例如，拖拽“城市”组件到画布，选择操作符“等于”，并输入值“北京”。

2.  **协议转换 (DSL Transformation)**：
    前端组件将用户的拖拽行为转化为标准的 JSON 协议（参见下文 DSL 设计）。此过程屏蔽了底层代码细节。

3.  **校验与落库 (Validation & Storage)**：
    后端接收 JSON 配置，执行严格的 **Schema 校验**（如：检查“北京”是否为有效的城市枚举）。校验通过后，生成新的版本号（如 `v1.2`），并持久化到 MySQL。为保证高可用，通常会将生效版本的规则同步刷新到 Redis 或配置中心 (Nacos/Etcd)。

#### 3.2.2 运行态：从“触发”到“结果”

此阶段追求极致的性能（低延迟、高吞吐）。当用户触发业务行为（如“点击领取红包”）时：

1.  **事实准备 (Fact Assembly)**：
    上游业务系统（如交易系统）收集当前请求的上下文数据，称为 **Fact**。
    > *Example Fact*: `{ "userId": 123, "orderAmount": 250, "city": "Beijing" }`

2.  **引擎调用 (Engine Invocation)**：
    业务系统通过 RPC/SDK 调用规则引擎接口，传入 `RuleID` 和 `Fact`。

3.  **规则加载与解析 (Load & Parse)**：
    引擎根据 `RuleID` 获取规则定义。
    *   **性能关键点**：引擎不会每次请求都去解析 JSON 字符串。它通常维护一个 **对象池 (Object Pool)** 或 **本地缓存 (Local Cache)**，存储已预编译好的 **AST (抽象语法树)** 或 **可执行闭包**。只有在规则版本变更时，才会触发重新编译。

4.  **匹配与执行 (Matching & Action)**：
    引擎将 `Fact` 注入到规则模型中进行求值运算。
    *   **布尔运算**：计算 `Condition` 是否为 `True`。
    *   **动作返回**：如果命中，返回预设的 `Action` 指令。
    > *Example Action*: `{ "type": "send_coupon", "params": { "id": "C_888" } }`

5.  **业务回调 (Callback)**：
    上游业务系统接收到 Action 指令后，执行具体的业务操作（如调用发券服务、发送 Push 通知）。

---

## 4. 规则定义与 DSL 设计

为了让非技术人员（运营、风控人员）能配置规则，我们需要在“底层代码”和“用户界面”之间搭建一层 DSL (Domain Specific Language)。

### 4.1 常见的配置形态

不同业务阶段和用户角色对配置形态有不同诉求。

| 形态 | 典型 UI 交互 | 适用场景 | 用户友好度 | 表达能力 | 维护成本 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **表单配置 (Form)** | 固定字段填写 | 简单活动，如“满 100 减 10” | ⭐⭐⭐⭐⭐ | ⭐ | ⭐ |
| **决策表 (Decision Table)** | Excel 表格形式 | 规则结构相同但参数不同的批量规则，如运费计算、阶梯定价 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **决策树/流程图 (Flowchart)** | 拖拽节点连线 | 复杂的多阶段活动编排，如“准入->发奖->通知” | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **类 SQL/脚本 (Script)** | 代码编辑器 | 极度复杂的逻辑运算，或作为兜底方案 | ⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

**选型建议**：
- **运营人员**：首选“表单”或“决策表”，所见即所得。
- **产品/分析师**：偏好“流程图”，便于梳理业务全景。
- **研发/技术运营**：使用“脚本”处理边缘 case。

### 4.2 规则定义的 DSL 设计 (JSON 示例)

后端存储通常采用结构化的 JSON 来描述规则。设计 DSL (Domain Specific Language) 时，核心要点是**标准化算子**和**递归结构**。

#### 4.2.1 标准化定义示例

以下是一个包含**优先级**、**互斥组**、**递归条件**和**多重动作**的完整规则定义：

```json
{
  "rule_id": "RULE_1024",
  "rule_name": "双11新人满减_高活用户专享",
  "description": "针对北京/上海的高价值新人，满300减50",
  "priority": 100,             // 优先级：值越大越先执行
  "mutex_group": "new_user_promo", // 互斥组：同组内仅命中一条（通常配合优先级）
  "status": "active",          // 状态：active, inactive, draft
  
  // 条件定义 (Condition)：支持 AND/OR 嵌套的递归结构
  "condition": {
    "operator": "AND",
    "children": [
      // 基础条件：注册天数 <= 7
      { 
        "field": "user.register_days", 
        "operator": "lte", 
        "value": 7 
      },
      // 嵌套条件：(城市 IN [北京, 上海] OR 标签包含 high_value)
      {
        "operator": "OR",
        "children": [
          { "field": "user.city", "operator": "in", "value": ["北京", "上海"] },
          { "field": "user.tags", "operator": "contains", "value": "high_value" }
        ]
      },
      // 动态参数：购物车总金额 >= 300
      {
        "field": "cart.total_amount",
        "operator": "gte",
        "value": 300
      }
    ]
  },
  
  // 动作定义 (Action)：命中后执行的一组操作
  "actions": [
    { 
      "type": "benefit_send", 
      "params": { 
        "benefit_type": "coupon", 
        "template_id": "CP_2024_11_11", 
        "count": 1 
      } 
    },
    {
      "type": "notify_user",
      "params": {
        "channel": "push",
        "template": "congrats_msg"
      }
    }
  ]
}
```

#### 4.2.2 关键字段说明

- **`operator`**: 逻辑连接符 (`AND`, `OR`) 或 比较操作符 (`eq`, `gt`, `lt`, `in`, `contains`)。
- **`field`**: 也就是 **LHS (Left Hand Side)**，通常映射到上下文中的变量（如 `user.age`）。
- **`value`**: 也就是 **RHS (Right Hand Side)**，可以是常量，也可以是另一个变量。
- **`children`**: 用于构建组合模式 (Composite Pattern)，实现无限层级的逻辑嵌套。

---

## 5. 核心技术方案伪代码实现

### 5.1 方案一：基于表达式引擎 (Expression Engine)

适用于电商促销计算、简单准入等场景。核心是将规则字符串解析为 AST，运行时结合数据求值。

```text
EXPRESSION-ENGINE-MAIN(rule_string, context)
    // 1. 编译阶段：解析字符串为抽象语法树 (AST)
    ast ← COMPILE(rule_string)
    
    // 2. 运行阶段：基于上下文递归求值
    is_match ← EVALUATE(ast, context)
    
    if is_match == TRUE
        then PRINT "Rule Matched"
        else PRINT "Rule Not Matched"

EVALUATE(node, context)
    if IS-LEAF(node)
        //如果是叶子节点，直接从上下文中获取变量值或直接返回常量
        then return GET-VALUE(node, context)
    
    // 递归计算左右子树
    left_val ← EVALUATE(node.left, context)
    right_val ← EVALUATE(node.right, context)
    
    // 根据操作符进行计算
    switch node.operator
        case "AND": return left_val AND right_val
        case "OR":  return left_val OR right_val
        case ">=":  return left_val >= right_val
        // ... 其他操作符
```

### 5.2 方案二：基于规则集与优先级的引擎

适用于复杂业务，需要管理多条规则的执行顺序和依赖。

```text
RULE-ENGINE-EXECUTE(rules, fact)
    // 1. 冲突解决 (Conflict Resolution)：按优先级降序排序
    SORT-DESCENDING(rules, key=priority)

    // 2. 顺序匹配与执行
    for each rule in rules
        do if EVALUATE-CONDITION(rule.condition, fact) == TRUE
            then // 执行动作，可能会修改 fact
                 EXECUTE-ACTION(rule.action, fact)
                 
                 // 可选：排他逻辑 (Short-circuit)，命中一条即终止
                 if rule.is_exclusive == TRUE
                     then return
```

### 5.3 方案三：流程编排 (Pipeline/Chain)

适用于营销链路的各个阶段串联（如：准入校验 -> 权益计算 -> 发放接口 -> 消息通知）。

```text
PIPELINE-EXECUTE(context, handlers)
    // 遍历所有处理步骤
    for each handler in handlers
        do // 执行当前步骤
           handler(context)
           
           // 快速失败 (Fail Fast)：如果某一步骤不通过，直接中断
           if context.result == FALSE
               then LOG "Pipeline terminated at " + handler.name + ", reason: " + context.reason
                    return
```

### 5.4 选型建议

| 方案 | 实现复杂度 | 适用场景 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- | :--- |
| **自研表达式引擎** | 高 (编译原理) | 电商促销计算、简单活动准入 | **性能极致**、完全可控、无外部依赖 | 开发成本高，需维护词法/语法解析器 |
| **简单规则集 (Slice/Map)** | 低 | 规则数量少、逻辑简单的业务 | 开发快、易于理解 | 难以处理复杂依赖，性能随规则数量线性下降 |
| **流程编排 (Pipeline)** | 中 | 营销链路编排（如：准入->发奖->通知） | 代码结构清晰、解耦 | 侧重“流程控制”而非“逻辑推理” |
| **脚本语言集成 (Lua/JS)** | 中 | 需要极高动态性的场景 | 灵活性高，无需重编译 | 存在性能损耗 (Context Switch) 和安全风险 |

---

## 6. 进阶技术：Rete 算法原理 (Rete Algorithm)

当规则数量从几十条演进到成千上万条时，普通的循环遍历（方案二）性能会急剧下降。Rete 算法是规则引擎领域的经典算法，它通过“空间换时间”来解决大规模规则匹配效率问题。

### 6.1 核心思想

Rete 算法将规则编译成一张有向无环图 (DAG)。它的核心逻辑是：利用规则之间的相似性，避免重复计算。

- **Alpha 网络**：处理单表条件筛选（如：Age > 18）。
- **Beta 网络**：处理多对象之间的连接条件（如：User.ID == Order.UserID）。

### 6.2 为什么在营销场景中使用？

- **状态缓存**：如果用户属性没变，只有订单金额变了，Rete 网络可以只重新计算受影响的部分节点。
- **计算复用**：如果 100 个活动都要求“新用户”，在 Rete 网络中，“新用户”这个条件节点只需要计算一次。

---

## 7. 性能优化实践 (通用建议)

1.  **预编译 (Pre-compilation)**：
    无论是 AST 还是脚本，务必在服务启动或配置变更时进行预编译，避免在请求链路中进行昂贵的解析操作。

2.  **对象池化 (Object Pooling)**：
    使用对象池复用 `Context` 和 `Fact` 对象，减少高并发场景下的 GC 压力。

3.  **并行计算 (Concurrency)**：
    利用协程 (Coroutine) 或线程 (Thread) 并行执行互不依赖的规则组（例如同时校验“风控规则”和“人群规则”）。

4.  **位运算优化 (Bitwise Operations)**：
    对于海量人群标签的筛选（如“男性”且“北京”），可以使用 BitMap 进行位运算加速，避免逐个字符串比对。

---

## 8. 测试验证与发布风控

在营销领域，规则引擎直接控制着资金交易与营销预算。规则逻辑的错误或冲突可能导致严重的资产损失（资损）。因此，构建完善的测试与发布体系是保障系统稳定性的核心。

成熟的发布体系通常包含 **发布前验证** 和 **发布中控制** 两个阶段。

### 9.1 发布前：全链路逻辑验证

在此阶段，目标是确保规则逻辑符合预期，且不产生负面副作用。

1.  **单元测试 (Unit Testing)**
    -   **目标**：验证单一规则的原子逻辑正确性。
    -   **实现**：为规则配置“预期输入集”和“预期输出断言”。例如，针对“满100减20”规则，输入订单金额 99 元应不命中，输入 101 元应命中并计算出优惠金额 20 元。

2.  **仿真回溯 (Dry Run / Simulation)**
    -   **目标**：在真实数据分布下验证规则的经济影响，防止预算超支。
    -   **挑战与方案**：如何支撑万级甚至亿级历史订单的回溯？
        -   **离线回溯**：利用大数据平台 (Spark/MapReduce) 加载 T-1 日的历史订单数据，批量执行新规则，统计预计发放金额。
        -   **采样回溯**：针对实时性要求高的场景，随机抽取线上最近 1000 条流量进行模拟执行。

3.  **静态冲突检测 (Conflict Detection)**
    -   **目标**：识别新规则与存量规则的逻辑冲突。
    -   **示例**：检测是否存在两个互斥的活动（如“新人专享”与“老客回馈”）在同一人群条件上产生了交集，或者是否存在多个优惠叠加后导致商品负毛利。

### 9.2 发布中：渐进式风险控制

在此阶段，目标是限制潜在故障的影响范围。

1.  **灰度发布 (Canary Release)**
    -   **策略**：按 UserID 取模、地理区域或特定标签（如内部员工）进行逐步放量。
    -   **流程**：1% 流量 -> 观察监控 (错误率/耗时/预算消耗) -> 10% 流量 -> 50% 流量 -> 全量。

2.  **影子模式 (Shadow Mode)**
    -   **定义**：新规则在线上实时运行并接收真实流量，但**只记录计算结果，不产生实际业务影响**（如不发放权益）。
    -   **实现难点**：如何在不增加主链路延迟的前提下执行影子规则？
        -   **异步执行**：将请求上下文投递至消息队列 (Kafka/RocketMQ)，由独立的消费者服务执行影子规则并记录日志。
        -   **对比分析**：实时消费影子日志，与主线规则结果进行 Diff，生成一致性报告。

### 9.3 应急响应：版本管理与回滚

当线上出现异常时，必须具备秒级止损能力。

-   **不可变版本 (Immutable Versioning)**：每次发布生成唯一的版本号 (Snapshot)，严禁在原版本上直接修改。
-   **一键回滚 (One-Click Rollback)**：系统应维护“当前生效版本指针”。回滚操作仅需修改指针指向上一稳定版本 ID，并刷新内存缓存即可，无需重新部署代码。
