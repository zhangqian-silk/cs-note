# Bloom Filter

布隆过滤器（Bloom Filter）是一种**概率型数据结构**，用于高效判断一个元素是否存在于一个集合中。

其核心特点是**空间效率极高，但存在一定的误判率**，即可能错误地认为某个不在集合中的元素存在，但是判断不存在的元素，则一定不在。

## 核心原理

**位数组**

- 使用一个长度为 `m` 的二进制位数组（初始全为 0）作为存储结构
- 每个元素通过多个哈希函数映射到位数组的多个位置上

**哈希函数**

- 使用`k`个不同的哈希函数，每个函数将输入元素映射到位数组的某个位置
- 哈希函数需要独立且均匀分布，以降低冲突概率

## 工作流程

**添加元素**

- 将元素依次通过 `k` 个哈希函数，得到 `k` 个位置
- 将这些位置的二进制位设为 1

![](https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/bloom-filter-simple-schematic-diagram.png)

**查询元素是否存在**

- 将元素通过相同的 `k` 个哈希函数，得到 `k` 个位置
- 若所有位置的位均为 1，则认为元素**可能存在**于集合中；否则**一定不存在**

## 误判率分析

**假阳性（False Positive）**

- 当多个元素的哈希位置重叠时，可能导致误判。
- 误判率随元素数量增加而上升，但可通过调整参数控制

**参数关系**

- 位数组大小 `m` 越大，误判率越低。
- 哈希函数数量 `k` 需要平衡：`k` 过少会增加冲突概率，`k` 过多会更快占满位数组。
- 假如 `p` 为目标误判率，有如下参数关系：
  - $m = - \frac{n * ln(p)}{(ln2)^2}$
  - $k = (\frac{m}{n}) * ln(2)$

**推导过程**

- 误判率 `p`

  - `k` 次哈希函数中，某一 bit 位仍为 0 的概率为：

      $(1-\frac{1}{m})^k$

  - 插入 `n` 个元素后，仍为 0 的概率为

      $(1-\frac{1}{m})^{nk}$

  - 插入 `n` 个元素后，为 1 的概率为

      $1-(1-\frac{1}{m})^{nk}$

  - 某一元素对应的 `k` 个 bit 位，均为 1 的概率，即误判率为：

      $p = [1-(1-\frac{1}{m})^{nk}]^k$

  - 当 `m` 较大时，有

      $(1+\frac{1}{-m})^{-m} \approx e, (1-\frac{1}{m})^{nk} \approx e^{-\frac{kn}{m}}$

  - 即误判率 `p` 约等于

      $p = [1-(1-\frac{1}{m})^{nk}]^k \approx (1-e^{-\frac{kn}{m}})^k$

<br>

- 误判率最小时的 `k`，即最优的 `k`

  - 对 `p` 取自然对数

    $\ln{p} = k \ln{(1-e^{-\frac{kn}{m}})}$

  - 对 `k` 求导，并令导数为 0，化简得到

    $k_{opt} = \frac{m}{n}\ln{2}$

<br>

- 数组大小 `m`

  - 代入 `k` 的最优解至 `p` 中

    $p = (1-e^{-\frac{kn}{m}})^k \approx (1-e^{-\ln{2}})^{\frac{m}{n}\ln{2}} = (\frac{1}{2})^{\frac{m}{n}\ln{2}}$

  - 取对数，得

    $\ln{p} = \frac{m}{n}\ln{2}\ln{\frac{1}{2}} = -\frac{m}{n}(\ln{2})^2$

  - 化简，得

    $m = -\frac{n\ln{p}}{(\ln{2})^2}$

## 优缺点

**优点**

- **空间效率极高**：仅需存储二进制位，远小于哈希表等结构
- **查询时间快**：时间复杂度为 `O(k)`（`k` 为哈希函数数量）
- **支持海量数据**：适合处理大规模集合的成员判定问题

**缺点**

- **存在误判**：无法保证 100% 准确
- **无法删除元素**：传统布隆过滤器不支持删除操作（但可通过改进如计数布隆过滤器实现）

## 应用场景

**缓存系统**

- 防止缓存穿透，提前将数据库主键写入过滤器中，如查询不存在的数据时，先用布隆过滤器过滤请求

**分布式系统**

- 同步数据前快速判断数据是否已存在，减少网络传输

**爬虫与去重**

- 快速判断 URL 是否已被爬取

**数据库查询优化**

- 减少对不存在数据的磁盘查找（如 LevelDB 等使用布隆过滤器加速查询）

**黑名单**

- 判断某一 IP 或手机号码是否在黑名单中
- 判断邮箱地址是否在垃圾邮件列表中

## 改进与变种

**计数布隆过滤器（Counting Bloom Filter）**

- 用计数器代替二进制位，支持删除操作

**可扩展布隆过滤器**

- 动态调整位数组大小以适应数据量增长

**布谷鸟过滤器（Cuckoo Filter）**：

- 支持删除操作且空间效率更高，但实现更复杂

## 实现示例

**数据结构定义**

```go
type BloomFilter struct {
    bits     []byte      // 位数组（用byte的二进制位存储）
    m        uint        // 位数组总长度（单位：bit）
    k        uint        // 哈希函数数量
}
```

**初始化**

```go
// n: 预期元素数量, p: 目标误判率（例如0.01表示1%误判率）
func NewBloomFilter(n uint, p float64) *BloomFilter {
    m := calculateM(n, p)
    k := calculateK(n, m)
    return &BloomFilter{
        bits:     make([]byte, (m+7)/8), // 向上取整为字节
        m:        m,
        k:        k,
    }
}
```

**Add**

```go
// Add 添加元素到布隆过滤器
func (bf *BloomFilter) Add(data []byte) {
    for i := uint(0); i < bf.k; i++ {
        hash := bf.hash(data, i)
        index := hash % bf.m
        byteIndex := index / 8
        bitIndex := index % 8
        bf.bits[byteIndex] |= 1 << bitIndex // 设置对应bit为1
    }
}
```

**Contains**

```go
// Contains 检查元素是否可能存在（可能有误判）
func (bf *BloomFilter) Contains(data []byte) bool {
    for i := uint(0); i < bf.k; i++ {
        hash := bf.hash(data, i)
        index := hash % bf.m
        byteIndex := index / 8
        bitIndex := index % 8
        if (bf.bits[byteIndex] & (1 << bitIndex)) == 0 {
            return false
        }
    }
    return true
}
```

**辅助函数**

```go
// 哈希函数（基于FNV-1a，通过不同种子生成多个哈希值）
func (bf *BloomFilter) hash(data []byte, seed uint) uint {
    h := fnv.New32a()
    h.Write(data)
    h.Write([]byte{byte(seed)}) // 添加种子生成不同哈希
    return uint(h.Sum32())
}

// 计算位数组长度m（单位：bit）
func calculateM(n uint, p float64) uint {
    return uint(math.Ceil(-float64(n) * math.Log(p) / (math.Pow(math.Log(2), 2))))
}

// 计算哈希函数数量k
func calculateK(n, m uint) uint {
    return uint(math.Ceil(float64(m) / float64(n) * math.Log(2)))
}
```

## CBF（Counting Bloom Filter）

### 固定位宽计数器

固定位宽计数器是 CBF 的一种最自然的实现方式，用一个固定位宽的计数器替代原本的一位，通过空间换取删除的能力，元素添加和删除频率较低的场景（如网络流统计）。

**优缺点**

- **优点**：
  - 实现简单，删除操作可靠
  - 空间可控（固定位宽）
- **缺点**：
  - **计数器溢出风险**：若位宽过小（如4位），频繁添加/删除可能导致计数器溢出
  - **空间浪费**：大部分计数器可能长期为 0 或 1，高位宽浪费空间

**适用场景**

- 元素添加和删除频率较低的场景（如网络流统计）

**位宽计算**

- 假设每个计数器被选中的概率服从泊松分布，则每个计数器的期望命中次数 $\lambda$ 为：

    $\lambda = \frac{nk}{m}$

- 综合 `m` 与 `k` 的取值，化简得

    $k_{opt} = \frac{m}{n}\ln{2}, \lambda = \ln{2}$

- 泊松分布累积函数为

    $P(X\le{K}) = e^{-\lambda}\sum_{i=0}^k{\frac{\lambda^i}{i!}}$

- 当位宽为 4 时，K 实际取值为 16，此时溢出概率为

    $1-P(X\le16) \approx 3.33 \times 10^{-18}$

### 变长编码计数器

使用**可变位宽编码**（如 Golomb 编码）动态调整计数器占用空间，高频访问的计数器占用更多位，低频访问的计数器占用较少位。

**优缺点**

- **优点**：
  - 空间效率高（适应计数器值分布）

- **缺点**：
  - 实现复杂，需处理动态内存管理
  - 操作时间复杂度增加

**适用场景**

- 计数器值分布高度不均匀的场景（如热点数据监控）

### 分层结构

引入 **计数数组** 来统计元素数量，同时利用 **BF** 快速判断元素是否存在。

**优缺点**

- **优点**：
  - 减少对计数器的无效访问（降低内存带宽压力）

- **缺点**：
  - 需要维护两个数据结构，空间和计算开销增加

**适用场景**

- 高频查询但低频删除的场景（如缓存系统）

### 减法计数方案（Deletable Bloom Filter）

使用两个布隆过滤器，其中**主过滤器**记录元素存在性，**删除标记过滤器**：记录被删除的元素。

**优缺点**

- **优点**：
  - 无计数器溢出问题，空间开销小
- **缺点**：
  - 不支持多次添加/删除同一元素
  - 误删后无法恢复

**适用场景**

- 需要一次性删除操作的场景（如去重系统的数据过期）

### 概率计数器方案（Probabilistic Counting）

使用概率方法（如HyperLogLog）估计计数器值，以一定误差换取空间效率。

**实现方案**

- **计数器合并**：多个哈希位置共享一个概率计数器
- **估计值**：通过哈希冲突的概率模型推算实际计数值

**优缺点**

- **优点**：
  - 空间效率极高，适合海量数据
- **缺点**：
  - 删除操作不可靠（概率模型不支持逆向操作）
  - 仅适用于统计场景，无法精确计数

**适用场景**

- 大数据集的基数统计（如 UV 计数）

### 混合方案（Hybrid CBF）

结合标准布隆过滤器和计数功能，低频率元素使用标准过滤器，高频率元素使用计数器。

**实现方案**

- **阈值分割**：设定一个计数阈值（如 3），低于阈值用标准位，高于阈值用计数器
- **动态迁移**：当元素计数超过阈值时，迁移到计数器结构

**优缺点**

- **优点**：
  - 兼顾空间和功能灵活性
- **缺点**：
  - 实现复杂，需动态维护两种结构

**适用场景**

- 元素访问频率差异大的场景（如缓存系统中的冷热数据分离）

## Ref

- <https://javaguide.cn/cs-basics/data-structure/bloom-filter.html>
