# 规则引擎

## 1. 概述

在数字化营销系统中，**规则引擎 (Rule Engine)** 是将业务决策逻辑（Business Logic）与系统核心代码（System Code）解耦的关键组件。它允许业务运营人员通过图形化界面或领域特定语言（DSL）动态配置营销策略，而无需等待研发发版，从而实现营销活动的敏捷迭代。

核心价值：

- **解耦**：业务逻辑独立于应用程序代码。
- **敏捷**：支持热部署，策略变更秒级生效。
- **透明**：逻辑可视化，便于业务理解和管理。

---

## 2. 核心业务场景

营销系统中的规则引擎主要应用于"判断"与"计算"两大类场景。

### 2.1 活动准入与人群圈选 (Eligibility & Segmentation)

判断用户是否有资格参与某个活动或被划分为某类人群。

- **场景示例**：
  - "仅限注册时间在 30 天内的新用户参与"。
  - "过去 7 天在美妆类目消费超过 500 元的女性用户"。
  - "位于'北京'且当前设备为'iOS'的用户"。
- **逻辑特征**：主要涉及布尔逻辑运算（AND, OR, NOT）和比较运算（>, <, =, IN）。

### 2.2 权益发放与计算 (Benefit Distribution)

根据用户行为和属性，计算应发放的奖励类型及数量。

- **场景示例**：
  - **阶梯满减**：满 100 减 10，满 200 减 30，满 500 减 100。
  - **组合优惠**：购买 A 商品 + B 商品，B 商品打 5 折。
  - **随机红包**：根据用户等级（L1-L5），发放 [1.0, 5.0] 区间的随机金额红包，L5 用户获得大额概率更高。
- **逻辑特征**：涉及复杂的算术运算、条件分支（If-Then-Else）及概率计算。

### 2.3 动态定价与折扣 (Dynamic Pricing)

实时计算商品的最终成交价。

- **场景示例**：
  - 会员专享价：金牌会员 95 折，钻石会员 88 折。
  - 促销叠加：单品直降 + 平台券 + 支付优惠的叠加逻辑及互斥校验（如"不可与满减券同享"）。
- **逻辑特征**：涉及复杂的优先级排序（Priority）、互斥逻辑（Mutex）及高精度的浮点运算（Decimal）。

### 2.4 营销风控 (Risk Control)

在营销链路中实时拦截异常行为。

- **场景示例**：
  - **频次控制**：单用户单日领取优惠券不超过 3 张。
  - **黑名单拦截**：用户 ID 或设备指纹在黑名单中，直接拒绝。
  - **行为异常**：1 分钟内连续请求超过 60 次。
- **逻辑特征**：高并发下的实时计数（Sliding Window Counter）、黑名单匹配（Bloom Filter/Set）及异常检测。

### 2.5 任务与成就体系 (Gamification & Task System)

基于用户行为状态的累积与触发，实现"做任务-领奖励"的闭环。

- **场景示例**：
  - **累积型任务**：连续签到 7 天，额外奖励 100 积分。
  - **组合型任务**：完成"完善资料"且"首次下单"，解锁"新手勋章"。
  - **状态机流转**：用户从 L1 升级到 L2 时，自动发放升级礼包。
- **逻辑特征**：强依赖状态存储（Stateful），涉及时间窗口内的聚合计算（Count, Sum）及状态机变迁。

### 2.6 智能触达与消息路由 (Smart Touch & Message Routing)

决定在什么时间、通过什么渠道、向用户发送什么内容，以最大化点击率并降低打扰。

- **场景示例**：
  - **渠道路由**：优先发送 App Push；若用户未开启 Push 权限或 2 小时未读，则降级发送短信。
  - **疲劳度控制**：同一用户 24 小时内最多收到 2 条营销类消息。
  - **时机选择**：根据用户历史活跃习惯，预测其最可能打开 App 的时间段进行发送。
- **逻辑特征**：多条件分支路由（Switch-Case）、时间序列预测及流量控制（Rate Limiting）。

### 2.7 推荐干预与流量调控 (Recommendation Intervention)

**注**：此场景中，规则引擎通常作为"重排层 (Re-ranking Layer)"嵌入推荐系统，负责处理运营强规则和合规硬规则，是对推荐算法（千人千面）的补充。

- **场景示例**：
  - **强插/置顶**：大促期间，强制将"主会场入口"插入到 Feed 流的第 3 位。
  - **打压/降权**：评分低于 3.0 的商家，在推荐列表中权重降低 50%。
  - **多样性控制**：连续 5 个展示位中，不能出现同一类目的商品。
- **逻辑特征**：涉及对列表数据（List）的重排序（Re-rank）、过滤（Filter）和插入（Insert）。

### 2.8 售后与服务保障 (After-sales & Service)

**注**：此场景中，规则引擎通常作为"决策节点 (Decision Node)"嵌入工作流引擎 (Workflow Engine)，实现审批流程的自动化流转。

- **场景示例**：
  - **极速退款**：用户信用分 > 700 且退款金额 < 200 元，申请退款直接系统通过，无需人工审核。
  - **运费险赔付**：根据用户的收货地址与退货仓距离，自动计算应赔付的运费金额。
  - **自动赔付**：外卖订单超时 30 分钟，自动发放 5 元无门槛红包作为补偿。
- **逻辑特征**：涉及复杂的审批流（Workflow）、多数据源聚合（Data Aggregation）及置信度计算。

---

## 3. 技术架构设计

一个成熟的营销规则引擎不仅包含核心的计算模块，还涵盖了从规则配置到上线的完整生命周期管理。我们可以将系统划分为 **配置态 (Configuration Phase)** 和 **运行态 (Runtime Phase)** 两个阶段。

### 3.1 核心模块概览

| 模块 | 职责 | 关键技术实现思路 (后端) |
| :--- | :--- | :--- |
| **规则编辑器 (Editor)** | 供运营人员配置规则的 GUI 界面。支持决策树、决策表、自然语言 DSL。 | 前端组件 (React/Vue) + 后端 DSL 校验接口 |
| **规则仓库 (Repository)** | 存储规则元数据、版本管理、状态管理（草稿/发布/下线）。 | 关系型数据库 (MySQL) + 缓存 (Redis) |
| **规则编译器 (Compiler)** | 将前端配置的规则转化为机器可执行的代码或对象（AST/Plugin）。 | 词法分析 (Lexer), 语法分析 (Parser) -> AST |
| **执行引擎 (Runtime)** | 接收上下文数据 (Fact)，匹配规则，执行动作 (Action)。 | 解释器模式, 策略模式, Rete 算法 |
| **服务接口 (Service)** | 提供 RPC/HTTP 接口供上游业务调用。 | RPC, HTTP Framework |

### 3.2 全链路工作流

#### 3.2.1 配置态：从"视觉"到"结构化存储"

此阶段的目标是让非技术人员能够安全、准确地定义业务规则。

1.  **前端交互 (UI/UX)**：
    运营人员在可视化界面上进行操作。例如，拖拽"城市"组件到画布，选择操作符"等于"，并输入值"北京"。

2.  **协议转换 (DSL Transformation)**：
    前端组件将用户的拖拽行为转化为标准的 JSON 协议（参见下文 DSL 设计）。此过程屏蔽了底层代码细节。

3.  **校验与落库 (Validation & Storage)**：
    后端接收 JSON 配置，执行严格的 **Schema 校验**（如：检查"北京"是否为有效的城市枚举）。校验通过后，生成新的版本号（如 `v1.2`），并持久化到 MySQL。为保证高可用，通常会将生效版本的规则同步刷新到 Redis 或配置中心 (Nacos/Etcd)。

#### 3.2.2 运行态：从"触发"到"结果"

此阶段追求极致的性能（低延迟、高吞吐）。当用户触发业务行为（如"点击领取红包"）时：

1.  **事实准备 (Fact Assembly)**：
    上游业务系统（如交易系统）收集当前请求的上下文数据，称为 **Fact**。
    > *Example Fact*: `{ "userId": 123, "orderAmount": 250, "city": "Beijing" }`
    - **懒加载**：将高成本或低频字段定义为按需加载（如画像、风控标签），规则匹配到相应字段时再触发拉取，并写回本地缓存。

2.  **引擎调用 (Engine Invocation)**：
    业务系统通过 RPC/SDK 调用规则引擎接口，传入 `RuleID` 和 `Fact`。

3.  **规则加载与解析 (Load & Parse)**：
    引擎根据 `RuleID` 获取规则定义。
    *   **性能关键点**：引擎不会每次请求都去解析 JSON 字符串。它通常维护一个 **对象池 (Object Pool)** 或 **本地缓存 (Local Cache)**，存储已预编译好的 **AST (抽象语法树)** 或 **可执行闭包**。只有在规则版本变更时，才会触发重新编译。

4.  **匹配与执行 (Matching & Action)**：
    引擎将 `Fact` 注入到规则模型中进行求值运算。
    *   **布尔运算**：计算 `Condition` 是否为 `True`。
    *   **动作返回**：如果命中，返回预设的 `Action` 指令。
    > *Example Action*: `{ "type": "send_coupon", "params": { "id": "C_888" } }`

5.  **业务回调 (Callback)**：
    上游业务系统接收到 Action 指令后，执行具体的业务操作（如调用发券服务、发送 Push 通知）。

---

## 4. 规则定义与 DSL 设计

为了让非技术人员（运营、风控人员）能配置规则，我们需要在"底层代码"和"用户界面"之间搭建一层 DSL (Domain Specific Language)。

### 4.1 常见的配置形态

不同业务阶段和用户角色对配置形态有不同诉求。

| 形态 | 典型 UI 交互 | 适用场景 | 用户友好度 | 表达能力 | 维护成本 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **表单配置 (Form)** | 固定字段填写 | 简单活动，如"满 100 减 10" | ⭐⭐⭐⭐⭐ | ⭐ | ⭐ |
| **决策表 (Decision Table)** | Excel 表格形式 | 规则结构相同但参数不同的批量规则，如运费计算、阶梯定价 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **决策树/流程图 (Flowchart)** | 拖拽节点连线 | 复杂的多阶段活动编排，如"准入->发奖->通知" | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **类 SQL/脚本 (Script)** | 代码编辑器 | 极度复杂的逻辑运算，或作为兜底方案 | ⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

**选型建议**：
- **运营人员**：首选"表单"或"决策表"，所见即所得。
- **产品/分析师**：偏好"流程图"，便于梳理业务全景。
- **研发/技术运营**：使用"脚本"处理边缘 case。

### 4.2 规则定义的 DSL 设计 (JSON 示例)

后端存储通常采用结构化的 JSON 来描述规则。设计 DSL (Domain Specific Language) 时，核心要点是**标准化算子**和**递归结构**。

#### 4.2.1 标准化定义示例

以下是一个包含**优先级**、**互斥组**、**递归条件**和**多重动作**的完整规则定义：

```json
{
  "rule_id": "RULE_1024",
  "rule_name": "双11新人满减_高活用户专享",
  "description": "针对北京/上海的高价值新人，满300减50",
  "priority": 100,             // 优先级：值越大越先执行
  "mutex_group": "new_user_promo", // 互斥组：同组内仅命中一条（通常配合优先级）
  "status": "active",          // 状态：active, inactive, draft

  // 条件定义 (Condition)：支持 AND/OR 嵌套的递归结构
  "condition": {
    "operator": "AND",
    "children": [
      // 基础条件：注册天数 <= 7
      {
        "field": "user.register_days",
        "operator": "lte",
        "value": 7
      },
      // 嵌套条件：(城市 IN [北京, 上海] OR 标签包含 high_value)
      {
        "operator": "OR",
        "children": [
          { "field": "user.city", "operator": "in", "value": ["北京", "上海"] },
          { "field": "user.tags", "operator": "contains", "value": "high_value" }
        ]
      },
      // 动态参数：购物车总金额 >= 300
      {
        "field": "cart.total_amount",
        "operator": "gte",
        "value": 300
      }
    ]
  },

  // 动作定义 (Action)：命中后执行的一组操作
  "actions": [
    {
      "type": "benefit_send",
      "params": {
        "benefit_type": "coupon",
        "template_id": "CP_2024_11_11",
        "count": 1
      }
    },
    {
      "type": "notify_user",
      "params": {
        "channel": "push",
        "template": "congrats_msg"
      }
    }
  ]
}
```

#### 4.2.2 关键字段说明

- **`operator`**: 逻辑连接符 (`AND`, `OR`) 或 比较操作符 (`eq`, `gt`, `lt`, `in`, `contains`)。
- **`field`**: 也就是 **LHS (Left Hand Side)**，通常映射到上下文中的变量（如 `user.age`）。
- **`value`**: 也就是 **RHS (Right Hand Side)**，可以是常量，也可以是另一个变量。
- **`children`**: 用于构建组合模式 (Composite Pattern)，实现无限层级的逻辑嵌套。

---

## 5. 核心技术方案伪代码实现

### 5.1 方案一：基于表达式引擎 (Expression Engine)

适用于电商促销计算、简单准入等场景。核心是将规则字符串解析为 AST，运行时结合数据求值。

```text
EXPRESSION-ENGINE-MAIN(rule_string, context)
    // 1. 编译阶段：解析字符串为抽象语法树 (AST)
    ast ← COMPILE(rule_string)

    // 2. 运行阶段：基于上下文递归求值
    is_match ← EVALUATE(ast, context)

    if is_match == TRUE
        then PRINT "Rule Matched"
        else PRINT "Rule Not Matched"

EVALUATE(node, context)
    if IS-LEAF(node)
        //如果是叶子节点，直接从上下文中获取变量值或直接返回常量
        then return GET-VALUE(node, context)

    // 递归计算左右子树
    left_val ← EVALUATE(node.left, context)
    right_val ← EVALUATE(node.right, context)

    // 根据操作符进行计算
    switch node.operator
        case "AND": return left_val AND right_val
        case "OR":  return left_val OR right_val
        case ">=":  return left_val >= right_val
        // ... 其他操作符
```

### 5.2 方案二：基于规则集与优先级的引擎

适用于复杂业务，需要管理多条规则的执行顺序和依赖。

```text
RULE-ENGINE-EXECUTE(rules, fact)
    // 1. 冲突解决 (Conflict Resolution)：按优先级降序排序
    SORT-DESCENDING(rules, key=priority)

    // 2. 顺序匹配与执行
    for each rule in rules
        do if EVALUATE-CONDITION(rule.condition, fact) == TRUE
            then // 执行动作，可能会修改 fact
                 EXECUTE-ACTION(rule.action, fact)

                 // 可选：排他逻辑 (Short-circuit)，命中一条即终止
                 if rule.is_exclusive == TRUE
                     then return
```

### 5.3 方案三：流程编排 (Pipeline/Chain)

适用于营销链路的各个阶段串联（如：准入校验 -> 权益计算 -> 发放接口 -> 消息通知）。

```text
PIPELINE-EXECUTE(context, handlers)
    // 遍历所有处理步骤
    for each handler in handlers
        do // 执行当前步骤
           handler(context)

           // 快速失败 (Fail Fast)：如果某一步骤不通过，直接中断
           if context.result == FALSE
               then LOG "Pipeline terminated at " + handler.name + ", reason: " + context.reason
                    return
```

### 5.4 方案四：基于 Rete 算法的推理引擎 (Rete Algorithm)

当规则数量从几十条演进到成千上万条时，普通的循环遍历（方案二）性能会急剧下降。Rete 算法是规则引擎领域的经典算法，它通过"空间换时间"来解决大规模规则匹配效率问题。

> 详细的 Rete 算法原理、网络结构与编译流程请参考 [Rete Algorithm](./rete.md)。

**1. 核心思想**

Rete 算法的核心逻辑是：利用规则之间的相似性，避免重复计算。

它将规则编译成一张有向无环图 (DAG)，主要包含两类网络：
- **Alpha 网络**：处理单表条件筛选（如：Age > 18）。
- **Beta 网络**：处理多对象之间的连接条件（如：User.ID == Order.UserID）。

Rete 的关键优势在于 **增量计算**：当事实数据发生小幅变化时，只更新受影响的节点，而不是重算全部规则。

**2. 为什么在营销场景中使用？**

- **状态缓存**：如果用户属性没变，只有订单金额变了，Rete 网络可以只重新计算受影响的部分节点。
- **计算复用**：如果 100 个活动都要求"新用户"，在 Rete 网络中，"新用户"这个条件节点只需要计算一次。
- **低延迟**：大量规则并存时，增量传播能显著降低匹配时间。

**3. 适用性与边界**

- **适合**：规则数量大、条件高度重叠、事实频繁变更的在线匹配场景。
- **不适合**：规则数量很少或无复用、事实变化极少的离线批处理场景。

### 5.5 选型建议

| 方案 | 实现复杂度 | 适用场景 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- | :--- |
| **自研表达式引擎** | 高 (编译原理) | 电商促销计算、简单活动准入 | **性能极致**、完全可控、无外部依赖 | 开发成本高，需维护词法/语法解析器 |
| **简单规则集 (Slice/Map)** | 低 | 规则数量少、逻辑简单的业务 | 开发快、易于理解 | 难以处理复杂依赖，性能随规则数量线性下降 |
| **流程编排 (Pipeline)** | 中 | 营销链路编排（如：准入->发奖->通知） | 代码结构清晰、解耦 | 侧重"流程控制"而非"逻辑推理" |
| **脚本语言集成 (Lua/JS)** | 中 | 需要极高动态性的场景 | 灵活性高，无需重编译 | 存在性能损耗 (Context Switch) 和安全风险 |
| **Rete 推理引擎** | 极高 (图算法) | 规则量大(>1000)、条件重叠度高 | **增量计算**、高性能匹配 | 内存消耗大、实现难度极大 |

---

## 6. 性能优化实践 (技术方案详解)

### 6.1 预编译 (Pre-compilation)

**原理**：在传统的规则引擎中，解析阶段（Parsing）和执行阶段（Execution）往往耦合在一起，导致每次请求都需要重复进行词法/语法分析、AST 构建或反射查找，带来显著的 CPU 开销。
**预编译**技术将这两个阶段分离：在服务启动或规则变更时，将规则表达式（LHS/RHS）提前编译为高效的中间表示（IR）、闭包（Closure）或字节码（Bytecode）。在运行时（Runtime），引擎直接执行这些预处理好的指令序列，从而将计算复杂度从 $O(\text{parse} + \text{eval})$ 降低为纯粹的 $O(\text{eval})$。

**伪代码方案**：

```text
INIT-RULES(raw_rules)
    executors ← NEW-MAP()
    for each cfg in raw_rules
        do // 编译阶段：将配置转换为闭包或字节码
           executors[cfg.id] ← COMPILE-CONDITION(cfg.condition)

    // 原子替换全局规则缓存
    rule_cache ← executors

HANDLE-REQUEST(fact)
    // 获取当前生效的规则集
    executors ← rule_cache

    if HAS-KEY(executors, "target_rule")
        then exec ← executors["target_rule"]
             // 执行阶段：直接调用函数，避免反射
             if EXECUTE(exec, fact) == TRUE
                 then // 规则命中处理逻辑...
```

### 6.2 对象池化 (Object Pooling)

**原理**：在高吞吐量的场景下（如 QPS > 10k），频繁分配和销毁短生命周期对象（如 `Fact` 和 `Context`）会产生大量临时对象，导致垃圾回收（GC）频率升高及 CPU 使用率增加。通过引入对象池（Object Pool）技术（如 Go 语言中的 `sync.Pool`），可以复用已分配的内存块，显著降低内存分配开销和 GC 压力，从而提升系统的吞吐量和稳定性。

**伪代码方案**：

```text
PROCESS-REQUEST(req)
    // 1. 从池中获取对象，减少内存分配
    fact ← POOL-GET(fact_pool)

    // 2. 必须重置状态，防止数据污染
    CLEAR-ATTRIBUTES(fact)

    // 填充本次请求数据
    fact.attributes["uid"] ← req.uid

    // 3. 使用对象执行规则
    EVALUATE-ENGINE(fact)

    // 4. 归还对象
    POOL-PUT(fact_pool, fact)
```

### 7.3 并行计算 (Concurrency)

**原理**：现代服务器通常配备多核 CPU，而传统的单线程执行模型无法充分利用硬件资源。通过将规则集构建为**有向无环图 (DAG)** 或独立的规则组（如"人群定向"、"风控校验"、"库存检查"），可以利用 Fork-Join 模型并发执行互不依赖的计算任务。这种方式能显著降低长尾延迟（Tail Latency），总耗时取决于最慢的一条执行路径，而非所有规则耗时的总和。

**伪代码方案**：

```text
EVALUATE-PARALLEL(fact)
    // 定义独立的规则组
    groups ← {"targeting", "risk_control", "inventory"}
    final_result ← NEW-RESULT()

    // 并行执行
    parallel for each group in groups
        do // 执行子任务
           result ← EVALUATE-GROUP(group, fact)

           // 聚合结果（需保证线程安全）
           LOCK(mutex)
           MERGE(final_result, result)
           UNLOCK(mutex)

    // 隐式等待所有并行任务完成
    return final_result
```

### 6.4 懒加载 (Lazy Loading)

**原理**：在复杂的营销规则中，并非所有条件都会被求值（例如 `A && B`，若 A 为 false，则 B 无需计算）。
**懒加载**利用了逻辑运算的短路（Short-circuit）特性，将昂贵的数据获取操作（如远程 RPC 调用获取用户画像、数据库查询）延迟到真正需要该数据进行判断的时刻。这不仅减少了不必要的 I/O 调用，还有效防止了服务过载。

**伪代码方案**：

```text
GET-ATTRIBUTE(fact, key)
    // 1. 命中一级缓存直接返回
    if HAS-KEY(fact.cache, key)
        then return fact.cache[key]

    // 2. 触发加载（如调用 UserProfileService）
    // 实际场景需防范缓存击穿 (SingleFlight)
    value ← LOAD-DATA-WITH-SINGLE-FLIGHT(key)

    if value == NIL
        then return NIL

    // 3. 写入缓存并返回
    fact.cache[key] ← value
    return value

// 规则调用示例
// 只有当 EXECUTE() 执行到 "user.tags" 时，才会触发 GET-ATTRIBUTE
// if fact.level > 3 and CONTAINS(fact.tags, "vip") then ...
```

### 6.5 位运算优化 (Bitwise Operations)

**原理**：对于特征空间有限且离散的场景（如人群标签：性别、地域、设备类型），传统的字符串匹配效率低下。
利用 **BitMap** 或 **RoaringBitmap** 数据结构，可以将这些特征映射为二进制位。此时，复杂的集合运算（如"男性 且 (北京 或 上海)"）即可转化为 CPU 指令级的高效位运算（AND, OR, NOT, XOR）。这种方法利用了 CPU 的字长优势（单次指令处理 64 位），在海量数据筛选场景下能带来数量级的性能提升。

**伪代码方案**：

```text
MATCH-TAGS(user_tags)
    // 预定义掩码常量
    TAG_MALE    ← 1 << 0 // 0001
    TAG_BEIJING ← 1 << 1 // 0010
    TAG_IOS     ← 1 << 2 // 0100

    // 预计算：规则要求 "男性且在北京" -> 0001 | 0010 = 0011 (3)
    rule_mask ← TAG_MALE OR TAG_BEIJING

    // 运行时：仅需一次位与运算
    // 用户A (男性, 北京, IOS) -> 0111 (7) & 0011 (3) == 0011 (3) -> true
    // 用户B (女性, 北京)      -> 0010 (2) & 0011 (3) == 0010 (2) != 3 -> false

    if (user_tags AND rule_mask) == rule_mask
        then return TRUE
        else return FALSE
```

---

## 7. 测试验证与发布风控

在营销领域，规则引擎直接控制着资金交易与营销预算。规则逻辑的错误或冲突可能导致严重的资产损失（资损）。因此，构建完善的测试与发布体系是保障系统稳定性的核心。

成熟的发布体系通常包含 **发布前验证** 和 **发布中控制** 两个阶段。

### 7.1 发布前：全链路逻辑验证

在此阶段，目标是确保规则逻辑符合预期，且不产生负面副作用。

1.  **单元测试 (Unit Testing)**
    -   **目标**：验证单一规则的原子逻辑正确性。
    -   **实现**：为规则配置"预期输入集"和"预期输出断言"。例如，针对"满100减20"规则，输入订单金额 99 元应不命中，输入 101 元应命中并计算出优惠金额 20 元。

2.  **仿真回溯 (Dry Run / Simulation)**
    -   **目标**：在真实数据分布下验证规则的经济影响，防止预算超支。
    -   **挑战与方案**：如何支撑万级甚至亿级历史订单的回溯？
        -   **离线回溯**：利用大数据平台 (Spark/MapReduce) 加载 T-1 日的历史订单数据，批量执行新规则，统计预计发放金额。
        -   **采样回溯**：针对实时性要求高的场景，随机抽取线上最近 1000 条流量进行模拟执行。

3.  **静态冲突检测 (Conflict Detection)**
    -   **目标**：识别新规则与存量规则的逻辑冲突。
    -   **示例**：检测是否存在两个互斥的活动（如"新人专享"与"老客回馈"）在同一人群条件上产生了交集，或者是否存在多个优惠叠加后导致商品负毛利。

### 7.2 发布中：渐进式风险控制

在此阶段，目标是限制潜在故障的影响范围。

1.  **灰度发布 (Canary Release)**
    -   **策略**：按 UserID 取模、地理区域或特定标签（如内部员工）进行逐步放量。
    -   **流程**：1% 流量 -> 观察监控 (错误率/耗时/预算消耗) -> 10% 流量 -> 50% 流量 -> 全量。

2.  **影子模式 (Shadow Mode)**
    -   **定义**：新规则在线上实时运行并接收真实流量，但**只记录计算结果，不产生实际业务影响**（如不发放权益）。
    -   **实现难点**：如何在不增加主链路延迟的前提下执行影子规则？
        -   **异步执行**：将请求上下文投递至消息队列 (Kafka/RocketMQ)，由独立的消费者服务执行影子规则并记录日志。
        -   **对比分析**：实时消费影子日志，与主线规则结果进行 Diff，生成一致性报告。

### 7.3 应急响应：版本管理与回滚

当线上出现异常时，必须具备秒级止损能力。

-   **不可变版本 (Immutable Versioning)**：每次发布生成唯一的版本号 (Snapshot)，严禁在原版本上直接修改。
-   **一键回滚 (One-Click Rollback)**：系统应维护"当前生效版本指针"。回滚操作仅需修改指针指向上一稳定版本 ID，并刷新内存缓存即可，无需重新部署代码。

---

## 8. 开源方案对比与选型

在生产环境中选择规则引擎方案时，需要综合考虑性能、生态、学习曲线和团队技术栈。

### 8.1 主流开源方案对比

| 方案 | 语言 | 核心算法 | 特点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **Drools** | Java | ReteOO / Phreak | 功能全面、生态成熟、支持 CEP | 企业级 BRMS、复杂业务规则 |
| **Easy Rules** | Java | 简单遍历 | 轻量级、API 简洁、易上手 | 小型项目、学习入门 |
| **LiteFlow** | Java | 流程编排 | 组件化编排、支持脚本 | 业务流程编排、规则编排 |
| **Aviator** | Java | 表达式引擎 | 非规则引擎，但常用于表达式求值 | 简单计算、动态公式 |
| **go-rule-engine** | Go | Rete 变体 | 云原生、高性能 | 微服务架构、高并发场景 |
| **Grule** | Go | 正向推理 | DSL 语法友好 | Go 项目、中等复杂度规则 |
| **RulesEngine** | Python | 正向推理 | Pythonic、易集成 | 数据分析、快速原型 |

### 8.2 选型决策树

```text
是否需要复杂规则推理？
├── 否，只需简单计算
│   └── 选择表达式引擎（如 Aviator、Spring EL）
│
└── 是，需要规则匹配
    ├── 规则数量 < 100 条
    │   └── 选择轻量方案（Easy Rules、自研）
    │
    └── 规则数量 > 100 条
        ├── 需要 CEP（复杂事件处理）
        │   └── Drools
        │
        └── 只需规则匹配
            ├── Java 技术栈 → Drools / LiteFlow
            └── Go 技术栈 → Grule / go-rule-engine
```

### 8.3 性能基准参考

以下指标基于业内实践经验，供架构设计参考：

| 指标 | 目标值 | 说明 |
| :--- | :--- | :--- |
| 单规则匹配延迟 | < 1 ms | 简单布尔条件，内存命中 |
| 千条规则匹配延迟 | < 10 ms | 含节点共享，无远程调用 |
| 万条规则匹配延迟 | < 50 ms | Rete 网络，优化后可达 |
| 内存占用（万条规则） | < 100 MB | 取决于条件复杂度和节点共享率 |
| 单实例 QPS | > 10,000 | 无外部依赖的纯计算场景 |

> **注意**：实际性能受规则复杂度、条件重叠率、Fact 结构等因素影响，建议基于真实业务场景进行压测。

---

## 9. 与营销系统的集成边界

规则引擎作为营销系统的核心组件之一，其职责边界需要明确划分，避免职责膨胀导致系统耦合。

### 9.1 规则引擎的职责

| 职责 | 说明 |
| :--- | :--- |
| **条件匹配** | 接收上下文（Fact），返回是否命中及命中的规则 ID |
| **动作指令生成** | 返回结构化的动作指令，如 `{ "type": "send_coupon", "params": {...} }` |
| **规则版本管理** | 规则的增删改查、版本快照、发布状态管理 |
| **执行日志** | 记录规则匹配过程和结果，用于审计和排查 |

### 9.2 规则引擎不应承担的职责

| 职责 | 应归属模块 | 原因 |
| :--- | :--- | :--- |
| **权益发放** | 权益中心 | 需要与外部系统交互，涉及库存扣减、事务处理 |
| **消息推送** | 消息网关 | 涉及渠道对接、模板渲染、发送限流 |
| **用户画像查询** | CDP / 用户中心 | 规则引擎只消费数据，不应承担数据获取职责 |
| **资金计算** | 计费中心 | 涉及金融级精度和审计要求 |

### 9.3 典型交互流程

```text
┌─────────────┐    ①Fact     ┌─────────────┐
│  业务系统   │ ────────────> │  规则引擎   │
│ (交易/活动) │               │             │
└─────────────┘ <─────────── └─────────────┘
                  ②MatchResult
                       │
                       │ ③Action
                       ▼
              ┌─────────────────┐
              │    权益中心     │ ← 发放优惠券
              │    消息网关     │ ← 发送通知
              │    积分系统     │ ← 增加积分
              └─────────────────┘
```

**交互要点**：
1. 规则引擎返回动作指令，不直接执行业务操作
2. 业务系统负责调用下游服务完成实际动作
3. 规则引擎可异步返回结果（如通过消息队列），支持高并发场景

---

## 10. 规则引擎场景下的安全、稳定与可观测

本节聚焦规则引擎**特有的**安全、稳定性与可观测性考量，不涉及通用服务的认证、限流等机制。

### 10.1 安全性：规则引擎特有风险

#### 10.1.1 规则注入攻击

**风险**：恶意规则利用表达式引擎执行危险操作。

```java
// 危险示例：用户输入被直接拼接到规则中
String rule = "user.name == '" + userInput + "'";  // 风险！
// 若 userInput = "' || system('rm -rf /') || '"
// 将执行系统命令
```

**防护措施**：
- **沙箱执行**：禁用危险函数（如文件操作、网络调用、反射）
- **白名单机制**：只允许预定义的函数和操作符
- **AST 校验**：编译阶段检测非法节点

#### 10.1.2 敏感数据泄露

**风险**：规则日志或错误信息中暴露用户敏感信息。

**防护措施**：
- **字段脱敏**：规则引擎内部处理时对敏感字段（手机号、身份证）进行掩码
- **日志脱敏**：输出日志前自动过滤敏感字段
- **权限分离**：规则配置人员与规则执行环境隔离

#### 10.1.3 规则越权

**风险**：规则访问了不该访问的业务域数据。

**防护措施**：
- **命名空间隔离**：不同业务线的规则只能访问各自命名空间的数据
- **字段级权限**：规则只能访问 Fact 中被授权的字段

### 10.2 稳定性：规则引擎特有故障模式

#### 10.2.1 规则死循环

**风险**：规则 A 触发动作 B，动作 B 又触发规则 A，形成循环。

**防护措施**：
- **执行深度限制**：设置最大规则链执行深度（如 10 层），超限终止
- **执行时间限制**：单次规则匹配超时（如 100ms），超时熔断
- **循环检测**：在 Fact 中记录已触发的规则 ID，同一次请求中重复触发则跳过

#### 10.2.2 内存溢出

**风险**：Rete 网络的 Alpha/Beta Memory 缓存大量数据导致 OOM。

**防护措施**：
- **内存上限**：设置规则引擎进程内存上限，超出时拒绝加载新规则
- **LRU 淘汰**：对低频使用的规则内存进行淘汰
- **监控告警**：内存使用率超过 80% 时告警

#### 10.2.3 规则热更新导致的抖动

**风险**：高频规则变更导致缓存频繁失效，引发性能抖动。

**防护措施**：
- **版本切换原子性**：新版本完全加载后再切换指针，避免中间状态
- **预编译**：规则变更时先编译成 AST/字节码，再热加载

### 10.3 可观测性：规则引擎特有指标

#### 10.3.1 核心监控指标

| 指标名称 | 含义 | 告警阈值 |
| :--- | :--- | :--- |
| `rule_match_latency_ms` | 规则匹配延迟 | P99 > 50ms |
| `rule_match_total` | 规则匹配总次数 | - |
| `rule_hit_count` | 规则命中次数 | - |
| `rule_hit_rate` | 规则命中率 | 异常低时告警（如 < 1%） |
| `rule_engine_memory_bytes` | 规则引擎内存占用 | > 预设上限 80% |
| `rule_compile_errors` | 规则编译错误数 | > 0 |
| `rule_execution_errors` | 规则执行错误数 | > 0 |

#### 10.3.2 审计日志（必须记录）

规则引擎直接控制资金发放，审计日志是事后追责和问题排查的关键。

```json
{
  "trace_id": "abc123",
  "timestamp": "2024-01-15T10:30:00Z",
  "rule_id": "RULE_1024",
  "rule_version": "v1.2.3",
  "user_id": "U10086",
  "fact_snapshot": { "order_amount": 500, "user_level": 3 },
  "match_result": "HIT",
  "actions": [ { "type": "send_coupon", "params": { "id": "CP_001" } } ],
  "latency_ms": 12
}
```

#### 10.3.3 决策追踪（可选，用于复杂排查）

当规则引擎支持多规则并行执行时，需要追踪决策路径：

- **规则链路**：记录触发了哪些规则，以及规则的执行顺序
- **条件快照**：记录每个条件的求值结果（True/False）
- **未命中原因**：记录规则未命中的具体条件

---

## 11. 总结

规则引擎是营销系统的"大脑"，其核心价值在于将业务逻辑与代码解耦，实现策略的敏捷迭代。本文从业务场景、DSL 设计、技术方案、性能优化、测试发布、选型对比、集成边界以及安全稳定等多个维度进行了系统性阐述。

**关键要点回顾**：

1. **场景驱动**：根据业务复杂度选择合适的方案（表达式引擎 vs 规则引擎 vs Rete）。
2. **DSL 标准化**：统一的 JSON 协议是实现可视化编排和跨系统集成的基础。
3. **性能优化**：预编译、对象池、懒加载、位运算是提升性能的关键手段。
4. **风控为先**：规则引擎直接控制资金发放，测试、灰度、回滚机制不可或缺。
5. **边界清晰**：规则引擎只负责决策，不执行具体业务动作，保持职责单一。
